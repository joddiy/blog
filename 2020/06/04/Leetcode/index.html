
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Jz Blog">
    <title>Leetcode Top 100 - Jz Blog</title>
    <meta name="author" content="Joddiy Zhang">
    
    
        <link rel="icon" href="http://joddiy.cc/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Joddiy Zhang","sameAs":["https://github.com/joddiy","https://scholar.google.com/citations?user=KH-xv38AAAAJ&hl=en&oi=sra","https://www.linkedin.com/in/joddiyzhang/"],"image":"14108933.jpeg"},"articleBody":"lengthOfLongestSubstring (cache) O(n)\n\nWe set two indexes, i and j, i to indicate the start of slide window, and j for end.First we move j to the right, once we find a duplicated value, we stop, and calculate the length.Then, we move i to right to remove the first duplicated value.We also use a dict to store where we store the value.\n12345678910111213141516171819202122232425262728293031323334# O(kn)def solution(a):    i, j = 0, 0    indice = &#123;&#125;    ret = 0    while j &lt; len(a):        if a[j] in indice:            i = indice[a[j]]            # reconstruct the indice map            indice = &#123;a[k]: k for k in range(i+1, j+1)&#125;        else:            # only add the current element            indice[a[j]] = j        ret = max(ret, len(indice))        j += 1    return ret# O(n)def solution2(a):    i, j = 0, 0    indice = &#123;&#125;    ret = 0    while j &lt; len(a):        if a[j] in indice:            # once we find a duplicate key            # then valid path must be the length between these two key minus 1            i = max(indice[a[j]], i)        ret = max(ret, j-i+1)        indice[a[j]] = j+1        j += 1    return retprint(solution2(&quot;abcabcbb&quot;))\n\nfindMedianSortedArrays (binary search) O(log(m+n))\n\n\n\n      left_part          |        right_part\nA[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]\nB[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]\n\nWe use i and j to divide the list A and B. Once we reach following conditions, we can get the median.-\tlen(left_part)&#x3D;len(right_part)-\tmax(left_part)≤min(right_part)-\tmedian &#x3D; (max(left_part) + min(right_part)) &#x2F; 2\nWe can simplify the condition to:-\tB[j−1]≤A[i] and A[i−1]≤B[j]-\tj&#x3D;(m+n+1)&#x2F;2-i\nWe do binary search to find the i:-\tif B[j−1]≤A[i] and A[i−1]≤B[j], we found the median-\tif B[j−1]&gt;A[i], we need to increase i using binary search-\tif A[i−1]&gt;B[j], we need to decrease i using binary search\nNote:-\timin, imax, half_len &#x3D; 0, m, (m+n+1)&#x2F;&#x2F;2-\ti &#x3D; (imin+imax)&#x2F;&#x2F;2, j &#x3D; half_len – i-\tif i &lt; m and nums2[j-1] &gt; nums1[i]: imin &#x3D; i + 1  # binary search-\telif i &gt; 0 and nums1[i-1] &gt; nums2[j]: imax &#x3D; i - 1  # binary search\n12345678910111213141516171819202122232425262728293031def solution(nums1, nums2):    m, n = len(nums1), len(nums2)    if m &gt; n:        nums1, nums2, m, n = nums2, nums1, n, m    imin, imax, half_len = 0, m, (m + n + 1) // 2    while imin &lt;= imax:        i = (imin + imax) // 2        j = half_len - i        if i &gt; 0 and nums1[i - 1] &gt; nums2[j]:            imax = i - 1        elif i &lt; m and nums1[i] &lt; nums2[j - 1]:            imin = i + 1        else:            if i == 0:                max_of_left = nums2[j - 1]            elif j == 0:                max_of_left = nums1[i - 1]            else:                max_of_left = max(nums1[i - 1], nums2[j - 1])            if (m + n) % 2 == 1:                return max_of_left            if i == m:                min_of_right = nums2[j]            elif j == n:                min_of_right = nums1[i]            else:                min_of_right = min(nums1[i], nums2[j])            return (max_of_left + min_of_right) / 2.\n\nlongestPalindrome (dp) O(N^2)\n\nWe set two indexes,’i’ and ‘j’, i to indicate the length of slide window, j to indicate the start of slide window, the dp formular is:\n\nP(i, j) &#x3D; P(i+1, j-1) + 2, if s[i] &#x3D;&#x3D; s[j].\n\nNote: \n\nP(i, i) &#x3D; 1\nsince ‘aa’ is also palindrome, so for P(i, i+1) &#x3D; 2 if s[i] &#x3D; s[i+1]\n\n1234567891011121314151617181920212223# O(n^2)def solution(s):    n = len(s)    dp = [[0] * n for i in range(n+1)]    ret = &quot;&quot;    max_len = 0    # i is the length, j is the start position    for i in range(1, len(s)+1):        for j in range(len(s)-i+1):            # case 1, single char            if i == 1:                dp[i][j] = 1            # case 2, continuous smae char            elif i == 2:                if s[j] == s[j+1]:                    dp[i][j] = 2            else:                if dp[i-2][j+1] &gt; 0 and s[j] == s[j+i-1]:                    dp[i][j] = dp[i-2][j+1] + 2            if dp[i][j] &gt; max_len:                max_len = dp[i][j]                ret = s[j:j+i]    return ret\n\nisMatch (recursive with memo) O(MN)\n\nWe can add memory to avoid repeated check.\n12345678910111213141516171819def solution(s, p):    memo = &#123;&#125;    m, n = len(s), len(p)    def recursive(i, j):        if (i, j) not in memo:            if j == n:                ans = i == m            else:                first_match = i &lt; m and p[j] in (s[i], &#x27;.&#x27;)                if j + 1 &lt; n and p[j + 1] == &#x27;*&#x27;:                    ans = recursive(                        i, j + 2) or first_match and recursive(i + 1, j)                else:                    ans = first_match and recursive(i + 1, j + 1)            memo[i, j] = ans        return memo[i, j]    return recursive(0, 0)\n\nmaxArea (trick) O(n)\n\nWe set i &#x3D; 0, and j &#x3D; len(heights), each time, we move the shorter height to find a higher height, and recalculate the max area. Beceuase if the next height is shorter than current height, it also has a short length on x-axis, it cannot have a larger volumn.\nNote: we cannot use dp, since this problem doesn’t have the optimal sub-structure.\nThis trick works, because we fasten the i and j from the outside to inside, the width will decrease, only if the height increase, there may exist a larger area. And why we move the shorter height, because, if we fix the shorter height, and move the higher height, the min height still is the shorter height, the max area will only decrease with the width.\n1234567891011# O(n)def solution(height):    i, j = 0, len(height) - 1    ret = min(height[j], height[i]) * (j-i)    while i &lt; j:        ret = max(ret, min(height[i], height[j]) * (j-i))        if height[i] &lt; height[j]:            i += 1        else:            j -= 1    return ret\n\n(mark) threeSum (trick) O(n^2)\n\nWe firstly sort the array, and then set three indexes, the first one is i, after we fix the i, we set j at the i+1, and k at the n-1, then we want the sum(s[j], s[k]) is -s[i], if the sum is less, we move the j&#x3D;j+1, else if the sum is larger, we move the k&#x3D;k-1(since the array is sorted).\n123456789101112131415161718192021222324# O(n^2) sortdef solution(nums):    n = len(nums)    nums.sort()    ret = []    for i in range(n-2):        if i &gt; 0 and nums[i] == nums[i-1]: # avoid repeat            continue        j, k = i+1, n-1        while j &lt; k:            s = nums[i] + nums[j] + nums[k]            if s &lt; 0:                j += 1            elif s &gt; 0:                k -= 1            else:                ret.append([nums[i], nums[j], nums[k]])                while j &lt; k and nums[j] == nums[j+1]: # avoid repeat                    j += 1                while j &lt; k and nums[k] == nums[k-1]: # avoid repeat                    k -= 1                j += 1                k -= 1    return ret\n\nletterCombinations (full permutation), O(3^N * 4^M)\n\nJust use recursive, within the function, use while to iterate all possible chars to call recursive function.\n1234567891011121314151617181920212223phone = &#123;&#x27;2&#x27;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;],         &#x27;3&#x27;: [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;],         &#x27;4&#x27;: [&#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;],         &#x27;5&#x27;: [&#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;],         &#x27;6&#x27;: [&#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;],         &#x27;7&#x27;: [&#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;],         &#x27;8&#x27;: [&#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;],         &#x27;9&#x27;: [&#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]&#125;def solution(digits):    ret = []    if not digits:        return ret    def recursion(prefix, digits):        if not digits:            ret.append(prefix)        else:            for c in phone[digits[0]]:                recursion(prefix+c, digits[1:])    recursion(&quot;&quot;, digits)    return ret\n\nremoveNthFromEnd (trick) O(n)\n\nWe use two indexes, I and j, and we let the I firstly move forward n steps, and then we move these two indexes together, once the I reach the end, the j is at last n-th node.\n123456789101112def solution(head, n):    t = ListNode(None)    t.next = head    p = t    q = t    for _ in range(n):        p = p.next    while p.next:        q = q.next        p = p.next    q.next = q.next.next    return t.next\n\ngenerateParenthesis (recursive) O(4^n&#x2F;√2)\n\nWe use a count n to record the remaining available left parentheses, and another count k to record the assigned left parentheses.-\tif n &#x3D;&#x3D; 0 and k &#x3D;&#x3D; 0, output-\tIf n &#x3D;&#x3D; 0 and k&gt;0, recursive(n, k-1), add ‘)’-\tIf n &gt; 0 and k &#x3D;&#x3D; 0, recursive(n-1, k+1), add ‘(’-\telse we should try two directions: recursive(n-1, k+1), add ‘(’, and recursive(n, k-1), add ‘)’\n1234567891011121314151617181920def solution(n):    ret = []    if n == 0:        return ret    def recursion(prefix, i, j):        # i means the assigned number of &quot;(&quot; and don&#x27;t have &quot;)&quot;        # j means the available number of &quot;(&quot;        if i==0 and j == 0:            ret.append(prefix)        elif i == 0:            recursion(prefix+&quot;(&quot;, i+1, j-1)        elif j == 0:            recursion(prefix+&quot;)&quot;, i-1, j)        else:            recursion(prefix+&quot;(&quot;, i+1, j-1)            recursion(prefix+&quot;)&quot;, i-1, j)    recursion(&quot;&quot;, 0, n)    return ret\n\nnextPermutation (trick), O(n)\n\nWe set j&#x3D;len(n)-1, and set i&#x3D;len(n)-2, we search the i from end to start, once we found n[i] &lt; n[j], we swop n[i] and n[j], then we reverse n[i:j+1]\nNote, from the last value, once we find a smaller value, we reverse all values between these two values.\n12345678910111213def solution(nums):    n = len(nums)    i = n - 2    while i &gt;= 0 and nums[i + 1] &lt;= nums[i]:        i -= 1    if i &gt;= 0:        j = n - 1        while j &gt;= 0 and nums[j] &lt;= nums[i]:            j -= 1        nums[i], nums[j] = nums[j], nums[i]        nums[i + 1:] = nums[:i:-1]    else:        nums[::] = nums[::-1]\n\nlongestValidParentheses\n\nlongestValidParentheses (stack trick) O(n)The idea behind this problem is, when we find a ‘)’ (stack is not empty), we need to check where does this start. So we record the position in the stack.\nOnce we encounter an invalid char(still need pop), or we has a ‘(’ now, we push its position into the stack, after that, when we encounter a “)”, we firstly pop a value from the stack, then we can always found the start point of the valid sub-path at the stack[-1].\n12345678910111213141516171819202122232425262728# dp O(n)def solution(s):    max_ret = 0    stack = [-1]    for i in range(len(s)):        if s[i] == &#x27;(&#x27;:            stack.append(i)        else:            stack.pop()            if len(stack) == 0:                stack.append(i) # last invalid point            else:                max_ret = max(max_ret, i - stack[-1]) # i-stack[-1] is current valid length    return max_ret# dp O(n)def solution(s):    ret = 0    dp = [0] * len(s)    for i in range(1, len(s)):        if s[i] == &quot;)&quot;:            if s[i - 1] == &quot;(&quot;:                dp[i] = (dp[i - 2] if i &gt; 1 else 0) + 2            elif i - dp[i - 1] &gt; 0 and s[i - dp[i - 1] - 1] == &quot;(&quot;:                dp[i] = dp[i-1] + 2 + \\                    (dp[i-dp[i-1]-2] if i-dp[i-1]-2 &gt; 0 else 0)        ret = max(ret, dp[i])    return ret\n\n(mark) longestValidParentheses (dp) O(n)the i-th element of dp arary indicates the length of the longest valid substring ending at i-th index. And because the valid substing always ends with ‘)’, we will have:-\ts[i-1,i] &#x3D; ‘()’, dp[i] &#x3D; dp[i-2]+2, (dp[i-1]&#x3D;0)-\ts[i-1,i] &#x3D; ‘))’, we need to check s[i-dp[i-1]-1], the last char before the longest substring ending at [i-1] whether is ‘(’, if it is, dp[i] &#x3D; dp[i-1] + dp[i-dp[i-1]-2]+2, the longest substing a [i-1] + substring before last valid substring + 2.\n1234567891011121314# dp O(n)def solution(s):    ret = 0    dp = [0] * len(s)    for i in range(1, len(s)):        if s[i] == &quot;)&quot;:            print(s[i], i, dp[i-1])            if s[i-1] == &quot;(&quot;:                dp[i] = (dp[i-2] if i &gt; 1 else 0) + 2            elif i-dp[i-1] &gt; 0 and s[i-dp[i-1]-1] == &quot;(&quot;:                dp[i] = dp[i-1] + 2 + \\                    (dp[i-dp[i-1]-2] if i-dp[i-1]-2 &gt; 0 else 0)        ret = max(ret, dp[i])    return ret\n(mark) search (binary search trick) O(log n)\n\nFor example, we take [4, 5, 6, 7, 0, 1, 2] as input, and s&#x3D;0, e&#x3D;n-1, m&#x3D;(s+e)&#x2F;&#x2F;2\nWe make these four assumptions:-\tthe axis locates at right, and target is at left: nums[s] &lt;&#x3D; target &lt; nums[m] -&gt; recursive(s, m-1)-\tthe axis locates at left, and target is at right: nums[m] &lt; target &lt;&#x3D; nums[e] -&gt; recursive(s+1, m)-\tthe axis locates at right, and target is at right: nums[m] &gt; nums[e]  -&gt; recursive(m+1, e)-\tthe axis locates at left, and target is at left: nums[s] &gt; nums[m] -&gt; recursive(s, m-1)\nFor third case, there is a hidden condition, , if nums[m] &gt; nums[e], this means the axis locates at right, so the nums[s] must be less than nums[m], at this condition, we only need to check the target if it locates at the right, since if the target locates at left, this case will be the first case. The same idea for fourth case.\nBesides, the recursion doesn’t break the rules of rotated list.\n1234567891011121314151617181920212223def solution(nums, target):    if not nums:        return -1    def recursion(i, j):        if j &lt; i:            return -1        m = (i+j)//2        if nums[m] == target:            return m        # target locates at non-axis side (and is left side)        elif nums[i] &lt;= target &lt; nums[m]:            return recursion(i, m-1)        # target locates at non-axis side (and is right side)        elif nums[m] &lt; target &lt;= nums[j]:            return recursion(m+1, j)        # target locates at axis side (and is right side)        elif nums[m] &gt; nums[j]:            return recursion(m+1, j)        # target locates at axis side (and is left side)        else:            return recursion(i, m-1)    return recursion(0, len(nums)-1)\n\nsearchRange (Binary Search trick) O(log n)\n\nwe use two binary search, one search the left boundary and another for the right boundary.\nWe modify the original binary search, make it to continue search when we found the target value. Also, once right_index &lt;left_index, we return left_index for the left boundary search, and return right_index for the right one.\n12345678910111213141516171819202122def solution(nums, target):    def recursiveLeft(s, e):        if e &lt; s:            return s        m = (s+e)//2        if nums[m] &lt; target:            return recursiveLeft(m+1, e)        else:            return recursiveLeft(s, m-1)    def recursiveRight(s, e):        if e &lt; s:            return e        m = (s+e)//2        if nums[m] &lt;= target:            return recursiveRight(m+1, e)        else:            return recursiveRight(s, m-1)    left, right = recursiveLeft(0, len(nums)-1), recursiveRight(0, len(nums)-1)    # once we cannot found the value, the left will right-1    return [left, right] if left &lt;= right else [-1, -1]\n\ncombinationSum (dfs) O(exponential)\n\njust add a loop to call the recursion function.\n123456789101112def solution(candidates, target):    ret = []    def recursion(prefix, i, target):        if target == 0:            ret.append(prefix)        for i in range(i, len(candidates)):            num = candidates[i]            if target - num &gt;= 0:                recursion(prefix+[num], i, target-num)    recursion([], 0, target)    return ret\n\nfirstMissingPositive (trick: hash with mod position) O(n)\n\nThe biggest challenge is, we can only use extra constant space which means we cannot set up a hash table with O(n) space. So the solution use the input array as the has table. \nUsing: nums[nums[i] % n] +&#x3D; n(first to handle all &lt;0 or &gt;&#x3D;n to 0), this to mark a bin has been covered, after iterating all values, we can check the value which less than n, the first value we found is the final result.\n12345678910111213def solution(nums):    nums.append(0) # very important, for example, [1]    n = len(nums)    for i in range(n):  # delete those useless elements        if nums[i] &lt; 0 or nums[i] &gt;= n:            nums[i] = 0    # use the index as the hash to record the frequency of each number    for i in range(n):        nums[nums[i] % n] += n # +n and %n to make the original value do not be overlaped    for i in range(1, n):        if nums[i] &lt; n:            return i    return n\n\nTrap (two dp, left and right) O(n)\n\nWe use two dp, to record both max heights from left and right respectively.-\tdp_l[i] &#x3D; max(dp_l[i-1], height[i])-\tdp_r[i] &#x3D; max(dp_r[i+1], height[i])\nThen, each bin’s water volume is: min(dp_l[i], dp_r[i]) - height[i].\n12345678910111213141516def solution(height):    height = [0] + height + [0]    n = len(height)    ret = 0    max_left = [0] * n  # record the max height from left    max_right = [0] * n  # record the max height from right    cur_max = height[0]    for i in range(n):        cur_max = max(cur_max, height[i])        max_left[i] = cur_max    cur_max = height[-1]    for i in range(n-1, -1, -1):        cur_max = max(cur_max, height[i])        max_right[i] = cur_max        ret += min(max_left[i], max_right[i]) - height[i]    return ret\n\n\nPermute (loop call recusive) O(2^n)\n\n123456789101112def solution(nums):    ret = []    n = len(nums)    def recursion(prefix, remaining):        if not remaining:            ret.append(prefix)        else:            for k in range(len(remaining)):                recursion(prefix+[remaining[k]], remaining[:k] + remaining[k+1:])    recursion([], nums)    return ret\n\nRotate (trick) O(n^2)\n\nFirst reverse and then transpose\n123456789101112def solution(matrix):    n = len(matrix)    i, j = 0, n - 1    # swap    while i &lt; j:        matrix[i], matrix[j] = matrix[j], matrix[i]        i += 1        j -= 1    # transpose    for i in range(n):        for j in range(i, n):            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n(mark) groupAnagrams (hash) O(m)\n\nusing collections.defaultdict(list), take the tuple(sorted(s)) as the key of hash table.\n1234567from collections import defaultdictdef solution(strs):    ret = defaultdict(list)    for s in strs:        ret[tuple(sorted(s))].append(s)    return list(ret.values())\n\n** sorted(s) is ok but set(s) cannot.\n(mark) maxSubArray (trick) O(n)\n\nWe scan the array from the left to right, we use a list to record the accumulated sum, only if the left sum is positive, we use it, otherwise, this negative value should be discarded. \nSo the sum is: nums[i] &#x3D; max(0, nums[i-1]) + nums[i]\nFor each continue positve sub-list, we compare to record the maximum sum: ret &#x3D; max(ret, nums[i]).\n1234567def solution(nums):    cur_sum = 0    max_v = - sys.maxsize    for num in nums:        cur_sum = max(0, cur_sum) + num        max_v = max(max_v, cur_sum)    return max_v\n\ncanJump (greedy) O(n)\n\nWe scan the list from the left to right up to the farest value we can reach, each time once we get a new value, we modify the farest value, so if we can attend the final position, return true, otherwise return false.\n1234567891011121314def solution(nums):    m = 0    for i in range(0, len(nums)):        if i &gt; m:            return False        m = max(m, i+nums[i])    return Truedef solution(nums):    i, max_i = 0, 0    while i &lt;= max_i and i &lt; len(nums) and max_i &lt; len(nums)-1:        max_i = max(max_i, i+nums[i])        i += 1    return max_i &gt;= len(nums) - 1\n\nmerge (greedy) O(n)\n\nWe firstly sort the input, then using a list, add the first tuple into the list, each time check whether the last tuple’s right value is larger than the second tuple’s first value, if yes, we merge this two, else only insert the tuple into the list.\n12345678910111213141516171819202122def solution(intervals):    intervals.sort(key=lambda x: x[0])    merged = []    for interval in intervals:        if not merged or merged[-1][1] &lt; interval[0]:            merged.append(interval)        else:            merged[-1][1] = max(merged[-1][1], interval[1])    return mergeddef solution(intervals):    intervals.sort(key=lambda x: x[0])    ret = []    while intervals:        interval_1 = intervals.pop(0)        if intervals and interval_1[1] &gt;= intervals[0][0]:            intervals[0][0] = interval_1[0]            intervals[0][1] = max(intervals[0][1], interval_1[1])        else:            ret.append(interval_1)    return ret\n\nuniquePaths (dp) O(m+n)\n\ndp[i][j] = dp[i][j-1] + dp[i-1][j]\n12345678910def solution(m, n):    dp = [[0] * n for _ in range(m)]    for i in range(m):        dp[i][0] = 1    for j in range(n):        dp[0][j] = 1    for i in range(1, m):        for j in range(1, n):            dp[i][j] = dp[i][j-1] + dp[i-1][j]    return dp[-1][-1]\n\nminPathSum (dp) O(mn)\n\ndp[i][j] = min(dp[i][j-1], dp[i-1][j]) + m[i][j]\n123456789101112def solution(grid):    m, n = len(grid), len(grid[0])    dp = [[0]*n for _ in range(m)]    dp[0][0] = grid[0][0]    for i in range(1, m):        dp[i][0] = dp[i-1][0] + grid[i][0]    for j in range(1, n):        dp[0][j] = dp[0][j-1] + grid[0][j]    for i in range(1, m):        for j in range(1, n):            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]    return dp[-1][-1]\n\nclimbStairs (dp) O(n)\n\ndp[i] = dp[i-1] + dp[i-2], dp[0]=1, dp[1] = 1\n123456789def solution(n):    if n == 1:        return 1    dp = [0] * n    dp[0], dp[1] = 1, 2    for i in range(2, n):        dp[i] = dp[i-1] + dp[i-2]    return dp[-1]\n\n(mark) minDistance (dc) O(mn)\n\nWe define a recursive function: recursive(word1, word2, i, j, memo), which returns the amount of operations for word1[i:] and word2[j:], and we use memo to record the sub-problem. \nFor the word1[i] and word2[j], if they are equal, we make memo[i][j] &#x3D; recursive(word1, word2, i+1, j+1, memo). Else, we define these three operations:-\tinsert &#x3D; 1 + recursive(word1, word2, i, j+1, memo), we insert word2[j] before word1[i], so they are eaqual, then we compare word1[i] with word2[j+1].-\tdelete &#x3D; 1 + recursive(word1, word2, i+1, j, memo), we delete word2[j], then we compare word1[i+1] with word2[j].-\treplace &#x3D; 1 + recursive(word1, word2, i+1, j+1, memo), we replace word1[i] with word2[j], so they are equal, so we continue to compare word1[i+1] with word2[j+1].\nand make memo[i][j] &#x3D; min(insert, delete, replace).\nFor the termination of the recursion, when i&#x3D;m, j&#x3D;n, it means we’ve handled all words, so return 0, else, when i&#x3D;m, we return n-j, when i&#x3D;n, we return m-i, since if we’ve already handled one word, we only need to insert the remaining chars in another word.\n1234567891011121314151617181920212223def solution(word1, word2):    memo = &#123;&#125;    n, m = len(word1), len(word2)    if m &lt; n:        word1, word2, m, n = word2, word1, n, m    def recursive(i, j):        if (i, j) not in memo:            if i == n:                ans = m - j            elif j == m:                ans = n - i            else:                if word1[i] == word2[j]:                    ans = recursive(i + 1, j + 1)                else:                    # insert, delete, replace                    ans = min(recursive(i, j + 1), recursive(i + 1, j),                              recursive(i + 1, j + 1)) + 1            memo[i, j] = ans        return memo[i, j]    return recursive(0, 0)\n\nsortColors (trick) O(n)\n\nWe use three indexes, i, j, k, the i and j indicate the range that we need to handle, and k indicates the value we are handling. For the nums[k], there are three cases:-\tnums[k] &#x3D;&#x3D; 0, we swap nums[i] and nums[k], then i+&#x3D;1, k+&#x3D;1.-\tnums[k] &#x3D;&#x3D; 1, do nothing, just k+&#x3D;1-\tnums[k] &#x3D;&#x3D; 2, we swap nums[j] and nums[k], then j-&#x3D;1.\nActually, the i indicates the end of “0” values, the j for start of “2” values, each time, we encounter a “0”, we swap it to the end of “0” values, and for “2” values, we swap it to the start of “2” values, so at final, the middle are all “1” values.\n1234567891011121314151617def solution(nums):    n = len(nums)    i, j, k = 0, 0, n-1    while i &lt;= k:        if nums[i] == 0:            if i != j:                nums[i], nums[j] = nums[j], nums[i]                j += 1            else:                j += 1                i += 1        elif nums[i] == 2:            nums[i], nums[k] = nums[k], nums[i]            k -= 1        else:            i += 1    return nums\n\nminWindow (trick hash) O(n)\n\nWe use two indexes i and j to indicate the start and end of the slide window. We also use a hash table to count amout of each char in T. The hash tbale m looks like a balance wallet, we first add chars of T into it, then once we encounter chars in S, we minus from m. So for m&gt;0 means there is still char we need to find, and m&lt;0 means we remove much more than we need in T. We also use a count&#x3D;len(T) to identify whether we have encounter all chars within T. First, we move the i to right, and we minus one from hash table m[s[i]], and we only minus one from count if we found m[s[i]]&gt;0(means we remove a target char), which means there are still uncount chars within T(because we may encounter several same chars, so the m[s[i]] could be negative, but for that time, we won’t minus from count). Once count equals to zero, we move j to right, each time we add one to m[s[i]], and we add one to count if we found m[s[i]]&gt;0, which means there are still uncount chars within T again.\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970def minWindow(self, s, t):    &quot;&quot;&quot;    :type s: str    :type t: str    :rtype: str    &quot;&quot;&quot;    import sys    import collections    m = collections.defaultdict(int)    # m just like a balance wallet    # we first add chars of T into it    # then once we encounter chars in S    # we minus from m    # so for m&gt;0 menas there is still char we need to find    # m&lt;0 means we remove much more than we need in T    for c in t:        m[c] += 1    j = 0    # identify how many remaining chars in T we still need to find    count = len(t)    minLen = sys.maxsize    minStart = 0    for i in range(len(s)):        # only when m[s[i]] &gt; 0, means remaining chars in t        if m[s[i]] &gt; 0:            count -= 1        m[s[i]] -= 1        # we have found all chars in T, we start to move j        while count == 0:            if (i - j + 1) &lt; minLen:                minLen = i-j+1                minStart = j            m[s[j]] += 1            # when m[s[i]] &gt; 0, means we remove too much target chars            # we increase count to mark there are chars we need to find            if m[s[j]] &gt; 0:                count += 1            j += 1    if minLen &lt; sys.maxsize:        return s[minStart:minStart+minLen]    return &quot;&quot;def solution(s, t):    from collections import Counter    import sys    n = len(s)    i, j = 0, 0    c_t = Counter(t)    count = len(t)    b, l = 0, sys.maxsize    while j &lt; n:        if c_t[s[j]] &gt; 0:            count -= 1        c_t[s[j]] -= 1        while not count:            if (j-i+1) &lt; l:                l = j-i+1                b = i            c_t[s[i]] += 1            if c_t[s[i]] &gt; 0:                count += 1            i += 1        j += 1    if l &lt; sys.maxsize:        return s[b:b+l]    return &quot;&quot;\n\n\nSubsets (dfs) O(2^n)\n\nSame with permutation, but also output at intermediate nodes.\n12345678910def solution(nums):    n = len(nums)    ret = []    def recursion(prefix, i):        ret.append(prefix)        for j in range(i, n):            recursion(prefix+[nums[j]], j+1)    recursion([], 0)    return ret\n\n(mark) Exist (dfs) O(mn * len(words))\n\nWe dedine a recursive function: dfs(row, col, idx), means from nums[row][col] starts finding word[idx:]. We iterative all cells, and only call dfs from the cell which equals to word[0].\nWithin the recursive function. If idx &#x3D;&#x3D; len(word), return True, else we check four directions, if it equals to word[idx], we call recursive func, if all fail, return false.\n1234567891011121314151617181920212223def solution(board, word):    m, n = len(board), len(board[0])    def recursion(i, j, idx):        if idx == len(word):            return True        board[i][j] = &quot;#&quot;        if i+1 &lt; m and board[i+1][j] == word[idx] and recursion(i+1, j, idx+1):            return True        if j+1 &lt; n and board[i][j+1] == word[idx] and recursion(i, j+1, idx+1):            return True        if i-1 &gt;= 0 and board[i-1][j] == word[idx] and recursion(i-1, j, idx+1):            return True        if j-1 &gt;= 0 and board[i][j-1] == word[idx] and recursion(i, j-1, idx+1):            return True        board[i][j] = word[idx-1]        return False    for i in range(m):        for j in range(n):            if board[i][j] == word[0] and recursion(i, j, 1):                return True    return False\n\nlargestRectangleArea (left and right dp) O(n)\n\nWe use two array, left_min and right_min to record the position of first smaller value from left and right, so each rectangle’s area is: height[i] * (right_min[i] - left_min[i] -1)\nWe set left_min[0]&#x3D;-1, for left_min[i], we search from j&#x3D;i-1, each time we found height[j] &gt;&#x3D; height[i], we set j&#x3D;left_min[j] to recursively find the first smaller value.\n12345678910111213141516171819def solution(heights):    heights = [0] + heights + [0]    n = len(heights)    min_left = [0] * n    min_right = [0] * n    ret = 0    for i in range(1, n - 1):        tmp_i = i - 1        while tmp_i &gt; 0 and heights[tmp_i] &gt;= heights[i]:            tmp_i = min_left[tmp_i]        min_left[i] = tmp_i    for j in range(n - 2, 0, -1):        tmp_j = j + 1        while tmp_j &lt; n - 1 and heights[tmp_j] &gt;= heights[j]:            tmp_j = min_right[tmp_j]        min_right[j] = tmp_j    for i in range(1, n - 1):        ret = max(ret, heights[i] * (min_right[i] - min_left[i] - 1))    return ret\n\nmaximalRectangle (greedy) O(mn)\n\nWe use three arrays to record the most far height, left boundary and right boundary.\nFor height:-\tif matrix[i][j] &#x3D;&#x3D; ‘1’: height[j] +&#x3D; 1, else height[j] &#x3D; 0\nFor left:-\tif matrix[i][j] &#x3D;&#x3D; ‘1’: left[j] &#x3D; max(left[j], cur_left), else left[j] &#x3D; 0, cur_left &#x3D; j+1\nFor right:-\tif matrix[i][j] &#x3D;&#x3D; ‘1’: right[j] &#x3D; min(right[j], cur_right), else right[j] &#x3D; n, cur_right &#x3D; j.\nThe precess is, firstly we determine the height of the rectangle, then we find the most far left boundary and right boundary of this rectangle. We use cur_left to record the far left boundary of this line, and left[j] to record the far boundary of all lines, so max(left[j], cur_left) gives us the most far left boundary of the rectangle in this line.\n12345678910111213141516171819202122232425def solution(matrix):    if not matrix:        return 0    m, n = len(matrix), len(matrix[0])    left, right, height = [0] * n, [n] * n, [0] * n    max_v = 0    for i in range(m):        cur_left, cur_right = 0, n        for j in range(n):            if matrix[i][j] == &#x27;1&#x27;:                height[j] += 1                left[j] = max(left[j], cur_left)            else:                height[j] = 0                left[j] = 0                cur_left = j + 1            j = n - j - 1            if matrix[i][j] == &#x27;1&#x27;:                right[j] = min(right[j], cur_right)            else:                right[j] = n                cur_right = j        for j in range(n):            max_v = max(max_v, (right[j] - left[j]) * height[j])    return max_v\n\ninorderTraversal (iterative) O(n)\n\nusing a stack, each time pop a node, and push its children into the stack by this tuple (node.left, node.val, node.right), each time we found a value, we output it.\nAnother way: we firstly loop to push left node into the stack up to the most left leaf, each time we pop a node, ouput it, and add its left node recursively again.\n12345678910111213141516171819202122232425def solution(root):    ret = []    def recursion(root):        if not root:            return        recursion(root.left)        ret.append(root.val)        recursion(root.right)    recursion(root)    return retdef solution(root):    ret = []    stack = [root]    while stack:        node = stack.pop()        if not node:            continue        elif isinstance(node, int):            ret.append(node)        else:            stack.extend([node.right, node.val, node.left])    return ret\n\nnumTrees (dp) O(n^2)\n\nWe need to define two functions:-\tG(n): the number of unique BST for a sequence of length n.-\tF(i, n), 1 &lt;&#x3D; i &lt;&#x3D; n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.\nSo, G(n) &#x3D; F(1, n) + F(2, n) + … + F(n, n). And G(0)&#x3D;1, G(1)&#x3D;1.\nWe found that: F(i, n) &#x3D; G(i-1) * G(n-i).\nCombining the above two formulas, we obtain the recursive formula for G(n). i.e.\nG(n) &#x3D; G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0).\nSo we start from G(2), G(2) &#x3D; G(0) * G(1), G(3) &#x3D; G(0) * G(2) + G(1) * G(1) + G(2) * G(0), …, finally we get G(n).\nFirstly, I want to use 2D dp, but from the above solution, I found, we don’t care about the start point and end pint, we only care about the length of the sub-question. So we can only use 1D dp.\n1234567def solution(n):    dp = [0] * (n+1)    dp[0] = dp[1] = 1    for i in range(2, n+1):        for j in range(1, i+1):            dp[i] += (dp[j-1]*dp[i-j])    return dp[-1]\n\nisValidBST (post-order, dfs) O(n)\n\nThe first solution, we compare from down to up, we get the max and min value of each subtree. So, for a valid node, its value must larger than max value of left subtree and less than min value of right subtree.\nThe second solution, we compare from up to down, we set a range by two value: low bound and upper bound, each time we enter a left tree, we constrict the upper bound, and when we enter the right tree, we constrict the right bound.\n12345678910111213def solution(root):    if not root:        return True    def recursion(root, min_v, max_v):        if not root:            return True        elif root.val &lt;= min_v or root.val &gt;= max_v:            return False        else:            return recursion(root.left, min_v, root.val) and recursion(root.right, root.val, max_v)    return recursion(root.left, -sys.maxsize, root.val) and recursion(root.right, root.val, sys.maxsize)\n\n(mark) isSymmetric (dfs or bfs) O(n)\n\n1234567891011121314151617181920212223242526272829303132333435363738def solution(root):    if not root:        return True    def recursion(root1, root2):        if not root1 and not root2:            return True        elif root1 and root2:            if root1.val == root2.val:                return recursion(root1.left, root2.right) and recursion(                    root1.right, root2.left)            else:                return False        else:            return False    return recursion(root.left, root.right)def solution(root):    if not root:        return True    queue1 = [root.left, root.right]    queue2 = [root.right, root.left]    while queue1 and queue2:        node1 = queue1.pop(0)        node2 = queue2.pop(0)        if not node1 and not node2:            continue        elif node1 and node2 and node1.val == node2.val:            queue1.extend([node1.left, node1.right])            queue2.extend([node2.right, node2.left])        else:            return False    if not queue1 and not queue2:        return True    else:        return False\n\n(mark) buildTree (recursive) O(n)\n\nWe found that the preorder indicates each root by the level order, and each root will recursively split the inorder into two part, its left and right subtree. \nWe use a dict to record the position of inorder in order to find the value quickly, then we define a function to construct the tree: def helper(start, end). Each time we give the function the range of its value in the inorder tree, then we recursively construct its left and right subtree as:-\troot.left &#x3D; helper(start, idx-1)-\troot.right &#x3D; helper(idx+1, end)\n(if start &gt; end, return None)\n123456789101112131415def solution(preorder, inorder):    inorder_dict = &#123;v: k for k, v in enumerate(inorder)&#125;    def build(i, j):        if not preorder or i &gt; j:            return None        val = preorder.pop(0)        key = inorder_dict[val]        node = TreeNode(val)        node.left = build(i, key - 1)        node.right = build(key + 1, j)        return node    return build(0, len(inorder) - 1)\n\n(mark) Flatten (iterative pre-order dfs) O(n)\n\nEach time we find the deepest left node, and insert it to its parent node’s first right node, then we enter the right node to do the same thing.\n12345678910111213141516171819def solution(root):    if not root:        return None    def flatten(node):        if not node.left and not node.right:            return node        if node.left:            # get the deepest left node to append to its first right node            tmp_node = flatten(node.left)            tmp_node.right = node.right # append it right to the deepest node&#x27;s right            node.right = node.left # append the top left to its right            node.left = None        if node.right:            # return deepest right node            return flatten(node.right)    flatten(root)    return root\n\nmaxProfit (trick) O(n)\n\nThis problem is that, we want to find the tuple of [lowest, highest], and the highest value must appear after the lowest one. So we record the lowest, and each time we update:-\tlowest &#x3D; min(lowest, prices[i])-\tprofit &#x3D; max(profit, prices[i]-lowest)\n1234567def solution(prices):    cur_min = sys.maxsize    max_profit = 0    for p in prices:        cur_min = min(cur_min, p)        max_profit = max(max_profit, p - cur_min)    return max_profit\n\nmaxPathSum (tree dp) O(n)\n\nFrom the bottom to up, at each node, we calculate the max value from left and max value from right, we try to update the result &#x3D; max(result, left_max+right_max+node.val), and for the return value, we return the max value from left_max+node.val and right_max+node.val, remember we need to compare with 0, since if the value less than 0, we actually delete it from the path. \n123456789101112131415def solution(root):    max_v = -sys.maxsize    def recursive(root):        nonlocal max_v        if not root:            return 0        else:            left = recursive(root.left)            right = recursive(root.right)            max_v = max(max_v, left + right + root.val)            return max(left + root.val, right + root.val, 0)    recursive(root)    return max_v\n\nlongestConsecutive (hash) O(n)\n\nWe convert the array to set(nums), when we iterate the array, we check whether the nums[i]-1 is in the array, if yes, skip. So once we found a smallest value, then try to check tmp_num+1 one by one, so we can get its consecutive length.\n12345678910111213def solution(nums):    if not nums:        return 0    set_nums = set(nums)    max_v = 0    for num in nums:        if num - 1 not in set_nums:            count = 1            while num + 1 in set_nums:                num += 1                count += 1            max_v = max(max_v, count)    return max_v\n\ncopyRandomList (hash) O(n)\n\nwe using collections.defaultdict to store nodes which has been visited.\n123456789101112131415161718192021222324252627282930313233343536373839404142434445def solution(head):    node_dict = defaultdict(Node)    def build(node):        if not node:            return None        _node = Node(node.val)        node_dict[node] = _node        if node.random:            if node.random in node_dict:                _node.random = node_dict[node.random]            else:                _node.random = build(node.random)        if node.next:            if node.next in node_dict:                _node.next = node_dict[node.next]            else:                _node.next = build(node.next)        return _node    return build(head)def solution(head):    if not head:        return None    node_dict = defaultdict(Node)    _head = Node(head.val)    node_dict[head] = _head    ret_head = _head    while head:        if head.random:            if head.random not in node_dict:                node_dict[head.random] = Node(head.random.val)            _head.random = node_dict[head.random]        if head.next:            if head.next not in node_dict:                node_dict[head.next] = Node(head.next.val)            _head.next = node_dict[head.next]        head = head.next        _head = _head.next    return ret_head\n\nwordbreak (dp) O(mn)\n\nWe set dp[i] as the result of s[0:i], and dp[i]&#x3D;true if dp[i-len(w)] and s[i-len(w):i] &#x3D;&#x3D; w.\n123456789def solution(s, wordDict):    n = len(s)    dp = [False] * (n + 1)    dp[0] = True    for i in range(1, n + 1):        for w in wordDict:            if i &gt;= len(w) and dp[i - len(w)] and s[i - len(w):i] == w:                dp[i] = True    return dp[-1]\n\nDetectCycle (trick) O(n)\n\nLet the distance from the first node to the node where cycle begins be A, and let say the slow pointer travels A+B. The fast pointer must travel 2A+2B to catch up. The cycle size is N. Full cycle is also how much faster pointer has traveled than slow pointer at meeting point.-\tA+B+N &#x3D; 2A+2B-\tN&#x3D;A+B\nSo once meet, we make another pointer start from head, we move slow pointer and this pointer together, once they meet, we found the beginning node. (because B+A&#x3D;N).\n12345678910111213def solution(head):    p = head    q = head    t = head    while p and q and p.next and q.next and q.next.next:        p = p.next.next        q = q.next        if q == p:            while q != t:                q = q.next                t = t.next            return t    return None\n\nLRUCache (double linked list) O(1)\n\nWe use double linked list here, and we make two basic operations, called remove and add. The remove is, remove a node by its id from the list, and add is add a node to the end of the tail.-\tFor the get operation, we firstly remove the node and then add.-\tFor the put operation, we add it into the list and remove a node from the head.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Node:        def __init__(self, k, x, next=None, pre=None):        self.key = k        self.val = x        self.next = next        self.pre = preclass LRUCache(object):        def __init__(self, capacity):        self.capacity = capacity        self.dict = &#123;&#125;        self.head = Node(0, 0)        self.tail = Node(0, 0)        self.head.next = self.tail        self.tail.pre = self.head    def get(self, key):        if key in self.dict:            node = self.dict[key]            self._remove(node)            self._add(node)             return node.val        else:            return -1    def put(self, key, value):        if key in self.dict:            self._remove(self.dict[key])        node = Node(key, value)        self._add(node)        self.dict[key] = node        while len(self.dict) &gt; self.capacity:            tmp_node = self.head.next            self._remove(tmp_node)            del self.dict[tmp_node.key]    def _remove(self, node):        p = node.pre        n = node.next        p.next = n        n.pre = p        def _add(self, node):        p = self.tail.pre        p.next = node        node.pre = p        node.next = self.tail        self.tail.pre = node\n\nSortList (merge sort or quick sort) O(nlogn)\n\nUsing three list to store nodes, using head as the partition node, left_head stores the nodes whose value is less than partition node, right_head stores the nodes whose value is larger than partition node. partition_head stores the nodes whose value is equal with its value.\nThen we recursive to call the sort function to sort left_head, right_head, at the final, we link these three lists together.\n1234567891011121314151617181920212223242526272829303132333435363738394041424344def solution(head):    if head is None:        return None    def recursive(head):        if head is None:            return None, None        partition_node = head        middle_head = ListNode(None)        middle_cur = middle_head        left_head = ListNode(None)        left_cur = left_head        right_head = ListNode(None)        right_cur = right_head        while head:            if head.val &lt; partition_node.val:                left_cur.next = ListNode(head.val)                left_cur = left_cur.next            elif head.val &gt; partition_node.val:                right_cur.next = ListNode(head.val)                right_cur = right_cur.next            else:                middle_cur.next = ListNode(head.val)                middle_cur = middle_cur.next            head = head.next                left_head, left_tail = recursive(left_head.next)        right_head, right_tail = recursive(right_head.next)        if left_head is not None:            left_tail.next = middle_head.next        else:            left_head = middle_head        if right_head is not None:            middle_cur.next = right_head.next        else:            right_tail = middle_cur        return left_head, right_tail    head, _ = recursive(head)    return head.next\n\n(mark) maxProduct (greedy) O(n)\n\nwe record the min and max value together, each time, we compare and update these two values.\n123456def solution(nums):    maximum = b = s = nums[0]    for num in nums[1:]:        b, s = max(num, b * num, s * num), min(num, b * num, s * num)        maximum = max(maximum, b)    return maximum\n\nMinStack (trick) O(n)\n\nWe use another stack to record the current min, each time we push a value, we compare it with the min[-1], if this valuer is larger, we duplicate min[-1], else we push value into the stack. And each time we need to pop a value, we also pop the min[-1].\n1234567891011121314151617181920212223242526272829303132333435363738class MinStack(object):    def __init__(self):        &quot;&quot;&quot;        initialize your data structure here.        &quot;&quot;&quot;        self.min = []        self.stack = []    def push(self, x):        &quot;&quot;&quot;        :type x: int        :rtype: None        &quot;&quot;&quot;        self.stack.append(x)        if not self.min:            self.min.append(x)        else:            self.min.append(min(self.min[-1], x))    def pop(self):        &quot;&quot;&quot;        :rtype: None        &quot;&quot;&quot;        self.stack.pop()        self.min.pop()    def top(self):        &quot;&quot;&quot;        :rtype: int        &quot;&quot;&quot;        return self.stack[-1]    def getMin(self):        &quot;&quot;&quot;        :rtype: int        &quot;&quot;&quot;        return self.min[-1]\n\nGetIntersectionNode (trick) O(m+n)\n\nFor two list p and q, we append the p-&gt;tail-&gt;q, and q-&gt;tail-&gt;p, so once we get _p==_q, we found the intersection.\n123456789101112131415161718192021222324252627282930313233343536373839404142def solution(headA, headB):    if not headA or not headB:        return None    nodeA = headA    nodeB = headB    while nodeA is not nodeB:        if not nodeA and nodeB:            return None        if nodeA.next is None:            nodeA = headB        else:            nodeA = nodeA.next        if nodeB.next is None:            nodeB = headA        else:            nodeB = nodeB.next    return nodeAdef solution(headA, headB):    def len(head):        ret = 0        while head:            ret += 1            head = head.next        return ret    lenA, lenB = len(headA), len(headB)    diff = abs(lenA - lenB)    if lenA &gt; lenB:        for _ in range(diff):            headA = headA.next    else:        for _ in range(diff):            headB = headB.next    while headA != headB:        headA = headA.next        headB = headB.next    return headA\n\nMajorityElement (trick) O(n)\n\n Make two variable, value and count, once count&#x3D;0, we make value&#x3D;nums[i], and count+&#x3D;1, if nums[i]&#x3D;&#x3D;value, make count+&#x3D;1, else count-&#x3D;1.\n123456789101112def solution(nums):    cur_value = nums[0]    cur_num = 1    for num in nums[1:]:        if num != cur_value:            cur_num -= 1            if cur_num == -1:                cur_value = num                cur_num = 1        else:            cur_num += 1    return cur_value\n\nRob (dp) O(n)\n\nSolution 1: using two arary, max_rob, max_not_rob. max_rob[i] means the max value when we rob nums[i], and max_not_rob means the max value when we don’t rob nums[i].-\tmax_rob[i] &#x3D; max_not_rob[i-1] + nums[i]-\tmax_not_rob[i] &#x3D; max(max_not_rob[i-1], max_rob[i-1])\nSolution 2:-\tf(0) &#x3D; nums[0]-\tf(1) &#x3D; max(num[0], num[1])-\tf(k) &#x3D; max(f(k-2) + nums[k], f(k-1))\n12345678910111213141516def solution(nums):    if not nums:        return 0    dp = [[0, 0] for _ in range(len(nums))]  # (rob, not_rob) * n    dp[0][0], dp[0][1] = nums[0], 0    for i in range(1, len(nums)):        dp[i][0] = dp[i - 1][1] + nums[i]        dp[i][1] = max(dp[i - 1])    return max(dp[-1])def solution(nums):    last, now = 0, 0    for i in nums:        last, now = now, max(last + i, now)    return now\n\nnumIslands (BFS DFS) O(mn)\n\nFor loop all cells, once found a ‘1’, using stack to do BFS, and for each cell visited, change it to ‘0’\n123456789101112131415161718192021222324252627def solution(grid):    if not len(grid) or not len(grid[0]):        return 0    ret = 0    n = len(grid)    m = len(grid[0])    for i in range(n):        for j in range(m):            if grid[i][j] == &quot;1&quot;:                grid[i][j] = &quot;0&quot;                ret += 1                queue = [(i, j)]                while queue:                    _i, _j = queue.pop(0)                    if _i &gt; 0 and grid[_i - 1][_j] == &quot;1&quot;:                        grid[_i - 1][_j] = &quot;0&quot;                        queue.append((_i - 1, _j))                    if _j &gt; 0 and grid[_i][_j - 1] == &quot;1&quot;:                        grid[_i][_j - 1] = &quot;0&quot;                        queue.append((_i, _j - 1))                    if _i &lt; n - 1 and grid[_i + 1][_j] == &quot;1&quot;:                        grid[_i + 1][_j] = &quot;0&quot;                        queue.append((_i + 1, _j))                    if _j &lt; m - 1 and grid[_i][_j + 1] == &quot;1&quot;:                        grid[_i][_j + 1] = &quot;0&quot;                        queue.append((_i, _j + 1))    return ret\n\n(mark) canFinish (dfs) O(n^3)\n\nWe set an array called visited to record which node has been visited. At the first, we set all visited[i]&#x3D;0. When we recursively to search each node, we set its visited[i]&#x3D;-1, once we’ve finished, we set it back to visited[i]&#x3D;1. So, when the recursive function found a visited[i]&#x3D;-1, return False, and visited[i]&#x3D;1(avoid repeatedly search), return True. \n1234567891011121314151617181920212223242526def solution(numCourses, prerequisites):    grid = [[] for _ in range(numCourses)]    visited = [0] * numCourses    for i, j in prerequisites:        grid[i].append(j)    def recusive(i):        if visited[i] == -1:            return False        if visited[i] == 1:            return True        visited[i] = -1        for j in grid[i]:            if not recusive(j):                return False        visited[i] = 1        return True    for i in range(numCourses):        if not recusive(i):            return False    return True\n\nTrie (tree) O(n)\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class TrieNode():    def __init__(self, val):        self.next = [None] * 26        self.val = valclass Trie(object):    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.root = TrieNode(False)    def insert(self, word):        &quot;&quot;&quot;        Inserts a word into the trie.        :type word: str        :rtype: None        &quot;&quot;&quot;        node = self.root        for w in word:            idx = ord(w) - ord(&#x27;a&#x27;)            if not node.next[idx]:                node.next[idx] = TrieNode(False)            node = node.next[idx]        node.val = True    def search(self, word):        &quot;&quot;&quot;        Returns if the word is in the trie.        :type word: str        :rtype: bool        &quot;&quot;&quot;        node = self.root        for w in word:            idx = ord(w) - ord(&#x27;a&#x27;)            if not node.next[idx]:                return False            node = node.next[idx]        return node.val    def startsWith(self, prefix):        &quot;&quot;&quot;        Returns if there is any word in the trie that starts with the given prefix.        :type prefix: str        :rtype: bool        &quot;&quot;&quot;        node = self.root        for w in prefix:            idx = ord(w) - ord(&#x27;a&#x27;)            if not node.next[idx]:                return False            node = node.next[idx]        return True\n\n(mark) findKthLargest (heap, quickselect) O(nlogn)\n\nThe heap is easy. The quickselect is similar with quicksort, each time we select a pivot, and partition the array to two parts, if the len(left_part)&#x3D;k-1, we return this pivot, else if larger, we continue to find k-th in the left_part, else, we found the k-len(left_part)-1-th at the right part.\n12345678910111213141516171819202122232425262728# O(klogk+2(n-k)logk)def solution(nums, k):    import heapq    k_heap = nums[0:k]    heapq.heapify(k_heap)    for i in range(k, len(nums)):        heapq.heappush(k_heap, nums[i])        heapq.heappop(k_heap)    return heapq.heappop(k_heap)# O(n)def solution(nums, k):    def recursive(nums, k):        pivot = nums.pop(len(nums) // 2)        right = [num for num in nums if num &gt; pivot]        lr = len(right)        if k == lr + 1:            return pivot        elif k &lt; lr + 1:            return recursive(right, k)        else:            left = [num for num in nums if num &lt;= pivot]            return recursive(left, k - lr - 1)    return recursive(nums, k)\n\nmaximalSquare (dp) O(n^2)\n\n\n   dp[i][j] &#x3D; min((dp[i-1][j-1]), (dp[i][j-1]), (dp[i-1][j])) + 1, if matrix[i][j]) &#x3D;&#x3D; 1\n   max_v &#x3D; max(max_v, dp[i][j])\n\n1234567891011121314151617def solution(matrix):    if not matrix or not matrix[0]:        return 0    dp = [[int(x) for x in row] for row in matrix]    max_v = 0    for i in range(len(matrix)):        for j in range(len(matrix[0])):            if i == 0 or j == 0:                max_v = max(max_v, dp[i][j])            elif matrix[i][j] == &quot;1&quot;:                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1                max_v = max(max_v, dp[i][j])            else:                dp[i][j] == 0    return max_v**2\n\ninvertTree (recursive) O(n)\n\nroot.left, root.right &#x3D; recursive(root.right), recursive(root.left)\n12345678def solution(root):    def recursive(root):        if root:            root.left, root.right = recursive(root.right), recursive(root.left)        return root    return recursive(root)\n\nisPalindrome (trick) O(n)\n\nWe use pointers, faster and slower, faster&#x3D;faster.next.next, slow&#x3D;slow.next. once we found he mid of the array, we reverse the half end of the list.\n12345678910111213141516171819def solution(head):    rev = ListNode(None)    fast = slow = head    while fast and fast.next:        fast = fast.next.next        _slow = slow        slow = slow.next        _slow.next = rev.next        rev.next = _slow    if fast:        slow = slow.next    rev = rev.next    while rev and slow:        if rev.val != slow.val:            return False        rev = rev.next        slow = slow.next    return True\n\nlowestCommonAncestor (recursive) O(n)\n\nuse postorder recursive, count &#x3D; recusive(root.left, p, q) + recusive(root.right, p, q), if root.val &#x3D;&#x3D;p or &#x3D;&#x3D;q: cur_count &#x3D;&#x3D;1 else 0. If count+cur_count &#x3D;&#x3D;2, return the result.\n123456789101112131415161718def solution(root, p, q):    low_desc = None    def recursive(root):        nonlocal low_desc        if not root:            return 0        ret = recursive(root.left)        if ret &lt; 2:            ret += recursive(root.right)        if root.val in (q.val, p.val):            ret += 1        if ret == 2 and not low_desc:            low_desc = root        return ret    recursive(root)    return low_desc\n\nproductExceptSelf (two pointers, reverse list) O(n)\n\nWe use two arrays, the first to record the product of left values, and second to record the product of right values. Then result[i] &#x3D; left[i] * right[i]\n123456789101112def solution(nums):    res = [1] * len(nums)    p = 1    for i in range(len(nums)):        res[i] = p        p *= nums[i]    right = 1    for i in range(len(nums) - 1, -1, -1):        res[i] *= right        right *= nums[i]    return res\n\nmaxSlidingWindow (trick) O(n)\n\nActually, we don’t need to re-calculate the max value each time. We use an array called result to record the max values. Each time:-\tIf the new value is larger than current max value, we add it into the result array.-\tElse if the value will be deleted from the window is less than current max value, we add the current max value into the result again.-\tElse we re-calculate the max value within the window.\n12345678910111213def solution(nums, k):    if not nums:        return nums    ret = [max(nums[:k])]    for i in range(1, len(nums) - k + 1):        if nums[i + k - 1] &gt;= ret[-1]:            ret.append(nums[i + k - 1])        elif nums[i - 1] &lt; ret[-1]:            ret.append(ret[-1])        else:            ret.append(max(nums[i:i + k]))    return ret\n\n(mark) searchMatrix (trick) O(m+n)\n\nAt the first row, we search from the end, exclude the values which are larger than target, and we record the index, then at the second row, we search from the index to exclude again. We return True once we found the target, else we return False.\n12345678910def solution(matrix, target):    if len(matrix) == 0 or len(matrix[0]) == 0:        return False    j = len(matrix[0]) - 1    for i in range(len(matrix)):        while j &gt;= 0 and matrix[i][j] &gt; target:            j -= 1        if matrix[i][j] == target:            return True    return False\n\nnumSquares (dp) O(n^1.5)\n\nfirst we set search range(nums) is [1, floor(n^0.5)], then for dp[i]&#x3D;min(dp[i-range[j]^2]+1) over all j.\n123456789101112131415import math, sysdef solution(n):    dp = [0] * (n + 1)    squares = [i**2 for i in range(1, int(math.sqrt(n)) + 1)]    dp[1] = 1    for i in range(2, n + 1):        min_v = sys.maxsize        for j in squares:            if i - j &lt; 0:                break            min_v = min(min_v, dp[i - j])        dp[i] = min_v + 1    return dp[-1]\n\nmoveZeroes (trick) O(n)\n\nEach time we encounter a non-zero value, we need to swap it with the first zero. So, we set an index to record the first zero’s position, if nums[i]!&#x3D;0, we add one to this index, and swap nums[index] with nums[i], else we do nothing. \n12345678910111213141516171819202122232425262728def solution(nums):    n = len(nums)    if n == 0 or n == 1:        return nums    i = 0    while i &lt; n and nums[i] != 0:        i += 1    j = i    while True:        while j &lt; n and nums[j] == 0:            j += 1        if j &gt;= n:            break        nums[i], nums[j] = nums[j], nums[i]        i += 1def solution(nums):    n = len(nums)    if n == 0 or n == 1:        return nums    i = 0    while i &lt; n and nums[i] != 0:        i += 1    for j in range(i + 1, n):        if nums[j] != 0:            nums[i], nums[j] = nums[j], nums[i]            i += 1\n\nfindDuplicate (trick) O(n)\n\nWe take this question as detectCycle, the number i will point to the nums[i], because there are multiply number are same, it means this number will point to a same number. And this number must be the start of the cycle.\n123456789101112def solution(nums):    slow = nums[0]    fast = nums[nums[0]]    while fast != slow:        fast = nums[nums[fast]]        slow = nums[slow]    slow = 0    while slow != fast:        slow = nums[slow]        fast = nums[fast]    return slow\n\nMedianFinder (trick) O(nlogn)\n\nSolution1: we maintain a sorted list, each time we using binary search to find the right position to insert the upcoming value.\nSolution2: we use two heaps, large heap and small heap. Each time, if the length of the two heaps is equal, then we firstly add the value into the large heap, then we pop the smallest value from the large heap, and then add it into the small heap. If length not equal, we add the value into the small heap and pop the largest value then add it into the large heap. Finally, if the length is equal, we return the average of the values from top of small and large heaps. If equal, we return the value from the top of large heap.\n12345678910111213141516171819202122232425262728293031323334import heapqclass MedianFinder(object):    def __init__(self):        &quot;&quot;&quot;        initialize your data structure here.        &quot;&quot;&quot;        self.left_heap = []        self.right_heap = []        heapq.heapify(self.left_heap)  # big heap        heapq.heapify(self.right_heap)  # small heap    def addNum(self, num):        &quot;&quot;&quot;        :type num: int        :rtype: None        &quot;&quot;&quot;        if len(self.left_heap) == len(self.right_heap):            heapq.heappush(self.left_heap,                           -heapq.heappushpop(self.right_heap, num))        else:            heapq.heappush(self.right_heap,                           -heapq.heappushpop(self.left_heap, -num))    def findMedian(self):        &quot;&quot;&quot;        :rtype: float        &quot;&quot;&quot;        if len(self.left_heap) == len(self.right_heap):            return float(-self.left_heap[0] + self.right_heap[0]) / 2.        else:            return float(-self.left_heap[0])\n\nSerialize (bfs) O(n)\n\nThe children of each node[i] is node[2i] and node[2i+1]\n12345678910111213141516171819202122232425262728293031323334353637383940414243def serialize(self, root):    &quot;&quot;&quot;Encodes a tree to a single string.        :type root: TreeNode    :rtype: str    &quot;&quot;&quot;    if not root:        return &#x27;&#x27;    out = []    queue = collections.deque([root])    while queue:        node = queue.popleft()        out.append(str(node.val) if node else &#x27;#&#x27;)        if node:            queue.append(node.left)            queue.append(node.right)    return &#x27; &#x27;.join(out)def deserialize(self, data):    &quot;&quot;&quot;Decodes your encoded data to tree.        :type data: str    :rtype: TreeNode    &quot;&quot;&quot;    if not data:        return None    out = data.split()    bfs = [TreeNode(int(i)) if i != &#x27;#&#x27; else None for i in out]    slow_idx = 0  # the id in array nodex    fast_idx = 1  # the id in array bfs    root = bfs[0]    nodes = [root]    while slow_idx &lt; len(nodes):        node = nodes[slow_idx]        slow_idx += 1  # each time we handle one node in nodes        node.left = bfs[fast_idx]        node.right = bfs[fast_idx + 1]        fast_idx += 2  # each time we only handle two nodes in bfs        if node.left:            nodes.append(node.left)        if node.right:            nodes.append(node.right)    return root\n\nlengthOfLIS(dp)\n\nlengthOfLIS(dp) O(n^2)The dp[i] stores the longest length till current position, each time we compare the current value with all previous values, if the current value is larger than a previous value, we record its dp value:\n123456789101112def lengthOfLIS(nums):    if len(nums) == 0:        return 0    dp = [0] * len(nums)    dp[0] = 1    for i in range(1, len(nums)):        max_t = 0        for j in range(0, i):            if nums[i] &gt; nums[j]:                max_t = max(max_t, dp[j]) # # longest length till now plus current         dp[i] = max_t + 1    return max(dp)\n\n(mark) lengthOfLIS(dp) O(nlogn)The dp[i] stores the increasing subsequence formed by including the currently encountered element.\nFor example, for input: [0, 8, 4, 12, 2],\nWe iterate each value in the input, each time we find the position in dp which value is the first one larger than current value in the input. For example, for 0, we have dp: [0]; for 8, we have dp: [0, 8]; for 4, we have dp: [0, 4]; then for 12, all values is smaller than 12, so we have append it at the end of dp: [0, 4, 12]; for 2, we have dp: [0, 2, 12]. The final dp is not the longest increasing subsequence, but length of dp array results in length of Longest Increasing Subsequence.\nThe reason why we update the value from [0, 4, 12] to [0, 2, 12], is 1, the update doesn’t break the feature of length of LIS,  2, once we encounter a value which is larger than 2, we update 12 then, so this makes sure we can find a longer LIS then. \n12345678910111213141516171819202122232425# o(n^2)def solution(nums):    dp = [1] * len(nums)    for i in range(1, len(nums)):        for j in range(i):            if nums[j] &lt; nums[i]:                dp[i] = max(dp[i], dp[j] + 1)    return max(dp)# O(n * logn)def solution(nums):    dp = [0] * len(nums)    size = 0    for n in nums:        i, j = 0, size        while i != j:            m = (i + j) // 2            if dp[m] &lt; n:                i = m + 1            else:                j = m        dp[i] = n        size = max(size, i + 1)    return size\n\nremoveInvalidParentheses(recursive) O(n^2)\n\nWe use a counter to check a string of parentheses is valid. The counter will increase when it is ‘(‘ and decrease when it is ‘)’. Whenever the counter is negative, we have more ‘)’ than ‘(‘ in the prefix.\nTo make the prefix valid, we need to remove a ‘)’. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s &#x3D; ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourselves to remove the first ‘)’ in a series of consecutive ‘)’s.\nAfter the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two ‘)’ in two steps only with a different order.\nFor this, we keep tracking the last removal position and only remove ‘)’ after that. So, we need two flags, the first i means till i the string is valid, and j means we should start removing ‘)’ from j. And for ‘)’ between i and j, we call recursive function to remove every ‘)’.\nNow one may ask. What about ‘(‘? What if s &#x3D; ‘(()(()’ in which we need remove ‘(‘?\nThe answer is: do the same from right to left.\nHowever, a cleverer idea is: reverse the string and reuse the code!\n1234567891011121314151617181920212223242526272829303132333435363738394041424344def removeInvalidParentheses(self, s):    &quot;&quot;&quot;    :type s: str    :rtype: List[str]    &quot;&quot;&quot;    def removeHelper(s, output, iStart, jStart, openParen, closedParen):        numOpenParen, numClosedParen = 0, 0        for i in range(iStart, len(s)):            if s[i] == openParen:                numOpenParen += 1            if s[i] == closedParen:                numClosedParen += 1            # We have only ONE extra closed paren we need to remove            if numClosedParen &gt; numOpenParen:                print(s)                if openParen == &#x27;(&#x27;:                    print(&quot;positive&quot;)                elif openParen == &#x27;)&#x27;:                    print(&#x27;negative&#x27;)                print(&quot;i=&quot;, i, numOpenParen, numClosedParen)                # Try removing this ONE closed paren at each position, skipping duplicates                print(jStart, i)                # jStart: always to search the first closedParen which can be removed                for j in range(jStart, i+1):  # &lt;=                    # can be the first char,                    # or the char which previous char isn&#x27;t closedParen, removing each one of the consequtive closedParen actually is the same                    if s[j] == closedParen and (j == jStart or s[j-1] != closedParen): # since when j == jStart, there isn&#x27;t j-1                        # Recursion: iStart = i since we now have valid # closed parenthesis thru i. jStart = j prevents duplicates                        # at the next recursion, we only need to search the iStart from the current i, and search the jStart from the current j                        # since we found the first invalid closedParen at the i, and we have removed a closedParen at j                        print(&quot;remove, j=&quot;, j, s[j])                        removeHelper(s[:j]+s[j+1:], output,                                     i, j, openParen, closedParen)                return        reversed = s[::-1]        print(reversed, &quot;now out of the loop&quot;)        if openParen == &#x27;(&#x27;:            removeHelper(reversed, output, 0, 0, &#x27;)&#x27;, &#x27;(&#x27;)        else:            output.append(reversed)    output = []    removeHelper(s, output, 0, 0, &#x27;(&#x27;, &#x27;)&#x27;)    return output\n\nmaxProfit(dp) O(3n)\n\nWe use stack [n][3], stack[i][0] records colldown action, stack[i][1] records buy action, stack[i][0] records sell action.-\tFor cooldown, we keep the largest profit from the previous day: stack[i][0] &#x3D; max(stack[i-1]).-\tFor buy, we only consider the previous cooldown action, stack[i][1] &#x3D; stack[i-1][0] - prices[i]. The [buy, cooldown, buy] action will not occur, since the previous cooldown is got from the largest actions(stack[i][0] &#x3D; max(stack[i-1])).-\tFor sell, stack[i][2] &#x3D; bought + prices[i]. And we record a bought value each time, bought &#x3D; max(bought, stack[i][1]), so each time we keep the max bought which means the samllest cost bought.\n\nwe record the bought to avoid the [sell, rest, sell], each time we keep the max bought which means the samllest cost bought\n\n123456789101112def solution(prices):    if not prices:        return 0    n = len(prices)    buy, sell, cooldown = [0] * n, [0] * n, [0] * n    bought = buy[0] = -prices[0]    for i in range(1, n):        buy[i] = cooldown[i - 1] - prices[i]        sell[i] = bought + prices[i]        cooldown[i] = max(buy[i - 1], sell[i - 1], cooldown[i - 1])        bought = max(bought, buy[i])    return max(buy[-1], sell[-1], cooldown[-1])\n\nmaxCoins(dp) O(n^3)\n\nFirst of all, dp[i][j] means, the maximum coins we get after we burst all the balloons between i and j in the original array. So dp[i][j] means we already burst all balloons between i and j. For the transition function:\n12for k in range(i+1, j):    coins = max(coins, nums[i]*nums[k]*nums[j] + recursion(i, k) + recursion(k, j))\n\nThis transition function basically says in order to get the maximum value we can get for bursting all the balloons between [ i , j] , we just loop through each balloon between these two indexes and make them to be the last balloon to be burst, which means we already burst all balloons from left to k-1, and from k+1 to right.72Notes: we append 1 to the start and end of input, each time we handle the solution from i+1 to j. we actually skep the first and last items. This trick assures the equation is correct: nums[i]*nums[k]*nums[j].\n123456789101112131415161718def solution(nums):    nums = [1] + nums + [1]    n = len(nums)    dp = [[0] * n for _ in range(n)]    def recursive(i, j):        if dp[i][j] or j == i + 1:            return dp[i][j]        coins = 0        for k in range(i + 1, j):            # we firstly burst (i,k) and (k,j), only leave (i,k,j) three ballons            coins = max(                coins,                nums[i] * nums[k] * nums[j] + recursive(i, k) + recursive(k, j))        dp[i][j] = coins        return coins    return recursive(0, n - 1)\n\ncoinChange(dp) O(nm)\n\ndp[i] &#x3D; min(dp[i-coin] + 1) for coin in coins.\n1234567891011121314151617def solution(coins, amount):    if len(coins) == 0:        return -1    if amount == 0:        return 0    coins = sorted(set(coins), reverse=True)    dp = [amount + 1] * (amount + 1)    dp[0] = 0    for i in range(1, amount + 1):        for c in coins:            if i == c:                dp[i] = 1                break            elif i &gt; c and dp[i - c] &gt; 0:                dp[i] = min(dp[i], dp[i - c] + 1)    return -1 if dp[-1] &gt; amount else dp[-1]\n\nRob(dp in a tree), O(n)\n\n12345678910111213def solution(root):    def recursive(root):        if not root:            return 0, 0        l_rob, l_not_rob = recursive(root.left)        r_rob, r_not_rob = recursive(root.right)        rob = l_not_rob + r_not_rob + root.val        not_rob = max(l_rob, l_not_rob) + max(r_rob, r_not_rob)        return rob, not_rob    return max(recursive(root))\n\ncountBits(dp) O(n)\n\nf[i]=f[i // 2] + i % 2\njust like shift one bit to left and add the remainder.\n12345def solution(num):    dp = [0] * (num + 1)    for i in range(1, num + 1):        dp[i] = dp[i // 2] + i % 2    return dp\n\ntopKFrequent(heap) O(nlogn)\n\n1234567891011121314151617from collections import defaultdictimport heapqdef solution(nums, k):    hash_map = defaultdict(int)    for num in nums:        hash_map[num] += 1    ret = []    i = 0    for key, val in hash_map.items():        if i &lt; k:            heapq.heappush(ret, (val, key))        else:            heapq.heappushpop(ret, (val, key))        i += 1    return [v for k, v in ret]\n\ndecodeString(stack) O(n)\n\nWe use a stack to record chars. Each time we have a ‘]’, we pop and record the chars until the ‘[’, then we continue to find all digital chars, and get handle then to get a 10-based value to repeat the chars we recorded between ‘[’ and ‘]’.\n12345678910111213141516def solution(s):    stack = [&quot;&quot;]    num = &quot;&quot;    for c in s:        if c.isdigit():            num += c        elif c == &quot;[&quot;:            stack.extend([num, &quot;&quot;])            num = &quot;&quot;        elif c == &quot;]&quot;:            chars = stack.pop()            n_chars = stack.pop()            stack[-1] += chars * int(n_chars)        else:            stack[-1] += c    return stack.pop()\n\nreconstructQueue(trick) O(nlog)\n\nFirst we order the list by, people &#x3D; sorted(people, key&#x3D;lambda x: (-x[0], x[1])), the descending order of the first element and ascending value by the second element. \nThen we inset the tuple by the index of second element: result.insert(p[1], p).\nThe reason behind this is, the tuple’s order only be affected by the tuple which is larger than it. So we first to handle the larger tuple. Then, for the second element, we insert it by ascending order to keep the result valid. \n123456def solution(people):    people = sorted(people, key=lambda x: (-x[0], x[1]))    ret = []    for p in people:        ret.insert(p[1], p)    return ret\n\ncanPartition\n\ncanPartition(dp) O(n*s), n&lt;&#x3D;200, s&lt;&#x3D;10000We make a matrix with n*s, n is the number of the input, and s is the sum(input)&#x2F;&#x2F;2. For a cell in the matrix, for example, for i-th row and j-th column, it mean with input[:i], can we get sum value of j. so, the process as following:-\tWe make all dp[i][nums[i]-1] &#x3D; 1 for i in range(m). it means other values are not selected, only the i-th value’s sum.-\tAnd when we iterate fo i from 1 to m and j from 0 to s. dp[i-1][j] &#x3D;&#x3D; dp[i][j] means when current value is not selected, the sum we get.. And dp[i][j] &#x3D; dp[i-1][j-nums[i]] means when current value is selected, the sum we get.\nPartition(dp) O(2^n with cutting branch)just reclusively call helper(nums[i+1:], target-num) for i, num in enumerate(nums)\n12345678910111213141516171819202122232425262728293031323334353637383940# O(N * S)def solution(nums):    sum_v = sum(nums)    if sum_v % 2 == 1:        return False    if max(nums) &gt; sum_v // 2:        return False    scale = sum_v // 2 + 1    dp = [[False] * scale for _ in range(len(nums))]    nums = sorted(nums, reverse=True)    dp[0][nums[0]] = True    for i in range(1, len(nums)):        dp[i][nums[i]] = True        for j in range(scale - 1, 0, -1):            if dp[i - 1][j]:                dp[i][j] = True            if j &gt; nums[i] and dp[i - 1][j - nums[i]]:                dp[i][j] = True            if dp[i][-1]:                return True    return dp[-1][-1]def solution(nums):    def recursive(nums, target):        for i, num in enumerate(nums):            if num &gt; target:                return False            elif num == target:                return True            elif recursive(nums[i + 1:], target - nums[i]):                return True        return False    sum_v = sum(nums)    if sum_v % 2 == 1:        return False    nums = sorted(nums, reverse=True)    return recursive(nums, sum_v // 2)\n\npathSum(dp) O(n)\n\nWe assume all paths are from root, then there is an old path called oldPathsum, when we continue to go down the tree, we have a new path called currPathSum, once oldPathsum &#x3D; currPathSum – target, we found a path, so we result +&#x3D; cache.get(oldPathsum, 0). \nNote, when we enter a node, we make cache[currPathSum] &#x3D; cache.get(currPathSum, 0) + 1, and then we iterate its children, and once we leave this node, we make cache[currPathSum] -&#x3D; 1.\n12345678910111213141516def solution(root, target):    def recursive(root, cur_sum):        if root:            nonlocal ret            cur_sum += root.val            ret += cache.get(cur_sum - target, 0)            cache[cur_sum] = cache.get(cur_sum, 0) + 1            recursive(root.left, cur_sum)            recursive(root.right, cur_sum)            cache[cur_sum] -= 1    ret = 0    cache = &#123;0: 1&#125;    recursive(root, 0)    return ret\n\nfindAnagrams(cache) O(n)\n\nUsing a 26 sized cache to stores the current frequency of substring. Each time we slide the window to update the cache and compare it with the cache of target. \n1234567891011121314151617181920212223242526272829303132333435def solution(s, p):    import collections    ret = []    p_counter = collections.Counter(p)    s_counter = collections.Counter(s[:len(p) - 1])    for i in range(len(p) - 1, len(s)):        s_counter[s[i]] += 1        pre_i = i - len(p) + 1        if s_counter == p_counter:            ret.append(pre_i)        s_counter[s[pre_i]] -= 1        if s_counter[s[pre_i]] == 0:            del s_counter[s[pre_i]]    return retdef solution(s, p):    l = len(p)    p_frequency = [0] * 26    ss_frequency = [0] * 26    res = []    for c in p:        p_frequency[ord(c) - 97] += 1    for c in s[0:l]:        ss_frequency[ord(c) - 97] += 1    if p_frequency == ss_frequency:        res.append(0)    for i in range(1, len(s) - l + 1):        ss_frequency[ord(s[i - 1]) - 97] -= 1        ss_frequency[ord(s[i + l - 1]) - 97] += 1        if p_frequency == ss_frequency:            res.append(i)    return res\n\nfindDisappearedNumbers(trick) (n)\n\nWe iterate the array, to mark the seen position as negative.\n123456789101112def solution(nums):    n = len(nums)    for i in range(n):        _num = abs(nums[i])        if _num &lt;= n:            nums[_num - 1] = -abs(nums[_num - 1])    ret = []    for i in range(n):        if nums[i] &gt; 0:            ret.append(i + 1)    return ret\n\nfindTargetSumWays(dp) O(n*2s) s&#x3D;sum(nums)the matrix of dp is dp[0:n][-s:s], for row is 0, we take dp[0][+-nums[0]] &#x3D;1, and then for later rows, dp[i][j] &#x3D; dp[i][j-nums[i]] + dp[i][j+nums[i]].\n\n\n1234567891011121314151617def solution(nums, S):    sum_v = sum(nums)    if sum_v &lt; S:         return 0    n = len(nums)    dp = [0] * (2 * sum_v + 1)    dp[nums[0]] += 1    dp[-nums[0]] += 1    for n in nums[1:]:        _dp = [0] * (2 * sum_v + 1)        for i in range(-sum_v, sum_v + 1):            if i + n &lt;= sum_v:                _dp[i] += dp[i + n]            if i - n &gt;= -sum_v:                _dp[i] += dp[i - n]        dp = _dp    return dp[S]\n\ndiameterOfBinaryTree(tree dp) (n)\n\nFrom the leave, at each parent, we update the result &#x3D; max(result, a+b+1), a is the longest length from left, b is from right. Then we transfer max(a, b) to this parent as its longest length.\n123456789101112131415def solution(root):    def recusive(root):        nonlocal ret        if not root:            return 0, 0        l = recusive(root.left)        r = recusive(root.right)        ret = max(ret, max(l) + max(r))        return max(l) + 1, max(r) + 1    ret = 0    recusive(root)    return ret\n\nsubarraySum(hash trick) O(n)\n\nsimilar with findTargetSumWays\n12345678910111213141516171819202122232425# O(n^2)def solution(nums, k):    n = len(nums)    ret = 0    dp = [[0] * (n + 1) for _ in range(n)]  # (start_pos, len)    for i in range(1, n + 1):        for j in range(0, n - i + 1):            if i == 1:                dp[j][i] = nums[j]            else:                dp[j][i] = nums[j] + dp[j + 1][i - 1]            if dp[j][i] == k:                ret += 1    return ret# O(n)def solution(nums, k):    cache = &#123;0: 1&#125;    cur_sum = 0    ret = 0    for n in nums:        cur_sum += n        ret += cache.get(cur_sum - k, 0)        cache[cur_sum] = cache.get(cur_sum, 0) + 1    return ret\n\nfindUnsortedSubarray(trick) O(n)\n\nWe firstly iterate from left, each time, we store the current max value, and once we found the current value is smaller than the current max value, we mark it position. Then we iterate from right using min value to do again. Finally the result is max(right-left+1, 0).\n12345678910111213141516171819def solution(nums):    n = len(nums)    if n &lt;= 1:        return 0    right = 0    cur_max = nums[0]    for i in range(1, n):        if nums[i] &lt; cur_max:            right = i        cur_max = max(cur_max, nums[i])            cur_min = nums[-1]    left = len(nums)-1    for i in range(n - 2, -1, -1):        if nums[i] &gt; cur_min:            left = i        cur_min = min(cur_min, nums[i])    return max(right - left + 1, 0)\n\nmergeTrees(recursive) O(n)\n\n12345678910111213141516def solution(t1, t2):    def recursive(t1, t2):        if not t1 and not t2:            return None        elif not t1:            return t2        elif not t2:            return t1        else:            t1.left = recursive(t1.left, t2.left)            t1.right = recursive(t1.right, t2.right)            t1.val = t1.val + t2.val            return t1    return recursive(t1, t2)\n\nleastInterval(trick) O(n)\n\n\n\n123456789101112def solution(tasks, n):    cache = [0] * 26    for c in tasks:        cache[ord(c) - ord(&#x27;A&#x27;)] += 1    cache.sort(reverse=True)    max_v = cache[0] - 1    idle_slots = max_v * n    for i in range(1, len(cache)):        if cache[i] == 0:            break        idle_slots -= min(cache[i], max_v)    return idle_slots + len(tasks) if idle_slots &gt; 0 else len(tasks)\n\n\ncountSubstrings\n\ncountSubstrings() O(n^2)12345678910111213n = len(s)if n &lt;= 1:    return ndp = [[0] * (n + 1) for _ in range(n)]  # (start_pos, len)ret = 0for i in range(1, n + 1):    for j in range(0, n - i + 1):        if i == 1 or (i == 2 and                      s[j] == s[j + 1]) or (s[j] == s[j + i - 1] and                                            dp[j + 1][i - 2]):            dp[j][i] = 1            ret += 1return ret\n\ncountSubstrings(Manacher’s Algorithm?) O(n)dailyTemperatures(stack) O(n)\n\nWe use a stack to store the values. We push the value which is smaller than then top item of stack. Once we have a value which is larger than top item, we pop all values which are smaller than the current value and mark the result as [current position – item position].\n1234567891011def solution(T):    ret = [0] * len(T)    stack = [(T[0], 0)]    for i in range(1, len(T)):        top = stack[-1]        if T[i] &gt; top[0]:            while stack and T[i] &gt; stack[-1][0]:                _t = stack.pop()                ret[_t[1]] = i - _t[1]        stack.append((T[i], i))    return ret\n","dateCreated":"2020-06-04T03:08:18+08:00","dateModified":"2020-11-25T14:45:35+08:00","datePublished":"2020-06-04T03:08:18+08:00","description":"Summary of Leetcode Top 100","headline":"Leetcode Top 100","image":["https://leetcode.com/static/images/LeetCode_logo_rvs.png","https://miro.medium.com/max/1000/0*kBHpKva09AsGj7RQ"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://joddiy.cc/2020/06/04/Leetcode/"},"publisher":{"@type":"Organization","name":"Joddiy Zhang","sameAs":["https://github.com/joddiy","https://scholar.google.com/citations?user=KH-xv38AAAAJ&hl=en&oi=sra","https://www.linkedin.com/in/joddiyzhang/"],"image":"14108933.jpeg","logo":{"@type":"ImageObject","url":"14108933.jpeg"}},"url":"http://joddiy.cc/2020/06/04/Leetcode/","keywords":"Leetcode","thumbnailUrl":"https://leetcode.com/static/images/LeetCode_logo_rvs.png"}</script>
    <meta name="description" content="Summary of Leetcode Top 100">
<meta property="og:type" content="blog">
<meta property="og:title" content="Leetcode Top 100">
<meta property="og:url" content="http://joddiy.cc/2020/06/04/Leetcode/index.html">
<meta property="og:site_name" content="Jz Blog">
<meta property="og:description" content="Summary of Leetcode Top 100">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/1.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/2.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/3.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/4.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/5.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/6.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/7.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/8.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/9.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/10.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/11.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/12.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/13.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/14.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/15.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/16.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/17.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/18.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/19.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/20.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/21.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/22.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/23.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/24.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/25.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/26.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/27.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/28.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/29.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/30.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/31.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/32.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/33.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/34.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/35.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/36.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/37.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/38.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/39.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/40.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/41.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/42.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/43.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/44.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/45.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/46.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/47.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/48.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/49.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/50.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/51.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/52.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/53.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/54.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/55.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/56.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/57.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/58.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/59.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/60.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/61.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/62.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/63.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/64.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/65.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/66.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/67.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/68.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/69.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/70.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/71.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/72.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/73.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/74.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/75.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/76.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/77.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/78.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/79.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/80.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/81.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/82.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/83.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/84.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/85.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/86.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/87.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/87.5.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/88.png">
<meta property="og:image" content="http://joddiy.cc/2020/06/04/Leetcode/89.png">
<meta property="article:published_time" content="2020-06-03T19:08:18.000Z">
<meta property="article:modified_time" content="2020-11-25T06:45:35.000Z">
<meta property="article:author" content="Joddiy Zhang">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://joddiy.cc/2020/06/04/Leetcode/1.png">
    
    
        
    
    
        <meta property="og:image" content="http://joddiy.cc/assets/images/14108933.jpeg"/>
    
    
        <meta property="og:image" content="https://leetcode.com/static/images/LeetCode_logo_rvs.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://leetcode.com/static/images/LeetCode_logo_rvs.png"/>
    
    
        <meta property="og:image" content="https://miro.medium.com/max/1000/0*kBHpKva09AsGj7RQ"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://miro.medium.com/max/1000/0*kBHpKva09AsGj7RQ"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-x8blglznjjnb9pnnwui5zw4h43ysufmsh1b0omicawm4vhqcutzqavokgpne.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Jz Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/14108933.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/14108933.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Joddiy Zhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p><a href="mailto:&#x6a;&#111;&#x64;&#x64;&#x69;&#121;&#x7a;&#104;&#97;&#110;&#x67;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;">&#x6a;&#111;&#x64;&#x64;&#x69;&#121;&#x7a;&#104;&#97;&#110;&#x67;&#x40;&#103;&#x6d;&#97;&#x69;&#108;&#x2e;&#x63;&#111;&#109;</a></p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/joddiy"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://scholar.google.com/citations?user=KH-xv38AAAAJ&hl=en&oi=sra"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Google Scholar"
                        >
                        <i class="sidebar-button-icon fab fa-google" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Scholar</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/joddiyzhang/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--partial"
             style="background-image:url('https://miro.medium.com/max/1000/0*kBHpKva09AsGj7RQ');"
             data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Leetcode Top 100
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-06-04T03:08:18+08:00">
	
		    Jun 04, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Algorithm/">Algorithm</a>


    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h1 id="lengthOfLongestSubstring-cache-O-n"><a href="#lengthOfLongestSubstring-cache-O-n" class="headerlink" title="lengthOfLongestSubstring (cache) O(n)"></a>lengthOfLongestSubstring (cache) O(n)</h1><img src="1.png" style="width:800px;"/>

<p>We set two indexes, i and j, i to indicate the start of slide window, and j for end.<br>First we move j to the right, once we find a duplicated value, we stop, and calculate the length.<br>Then, we move i to right to remove the first duplicated value.<br>We also use a dict to store where we store the value.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(kn)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">a</span>):</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    indice = &#123;&#125;</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(a):</span><br><span class="line">        <span class="keyword">if</span> a[j] <span class="keyword">in</span> indice:</span><br><span class="line">            i = indice[a[j]]</span><br><span class="line">            <span class="comment"># reconstruct the indice map</span></span><br><span class="line">            indice = &#123;a[k]: k <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, j+<span class="number">1</span>)&#125;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># only add the current element</span></span><br><span class="line">            indice[a[j]] = j</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, <span class="built_in">len</span>(indice))</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution2</span>(<span class="params">a</span>):</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    indice = &#123;&#125;</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">len</span>(a):</span><br><span class="line">        <span class="keyword">if</span> a[j] <span class="keyword">in</span> indice:</span><br><span class="line">            <span class="comment"># once we find a duplicate key</span></span><br><span class="line">            <span class="comment"># then valid path must be the length between these two key minus 1</span></span><br><span class="line">            i = <span class="built_in">max</span>(indice[a[j]], i)</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, j-i+<span class="number">1</span>)</span><br><span class="line">        indice[a[j]] = j+<span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(solution2(<span class="string">&quot;abcabcbb&quot;</span>))</span><br></pre></td></tr></table></figure>

<h1 id="findMedianSortedArrays-binary-search-O-log-m-n"><a href="#findMedianSortedArrays-binary-search-O-log-m-n" class="headerlink" title="findMedianSortedArrays (binary search) O(log(m+n))"></a>findMedianSortedArrays (binary search) O(log(m+n))</h1><!-- ![2.png](2.png) -->

<img src="2.png" style="width:800px;"/>

<pre><code>      left_part          |        right_part
A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
</code></pre>
<p>We use i and j to divide the list A and B. Once we reach following conditions, we can get the median.<br>-	len(left_part)&#x3D;len(right_part)<br>-	max(left_part)≤min(right_part)<br>-	median &#x3D; (max(left_part) + min(right_part)) &#x2F; 2</p>
<p>We can simplify the condition to:<br>-	B[j−1]≤A[i] and A[i−1]≤B[j]<br>-	j&#x3D;(m+n+1)&#x2F;2-i</p>
<p>We do binary search to find the i:<br>-	if B[j−1]≤A[i] and A[i−1]≤B[j], we found the median<br>-	if B[j−1]&gt;A[i], we need to increase i using binary search<br>-	if A[i−1]&gt;B[j], we need to decrease i using binary search</p>
<p>Note:<br>-	imin, imax, half_len &#x3D; 0, m, (m+n+1)&#x2F;&#x2F;2<br>-	i &#x3D; (imin+imax)&#x2F;&#x2F;2, j &#x3D; half_len – i<br>-	if i &lt; m and nums2[j-1] &gt; nums1[i]: imin &#x3D; i + 1  # binary search<br>-	elif i &gt; 0 and nums1[i-1] &gt; nums2[j]: imax &#x3D; i - 1  # binary search</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums1, nums2</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">    <span class="keyword">if</span> m &gt; n:</span><br><span class="line">        nums1, nums2, m, n = nums2, nums1, n, m</span><br><span class="line">    imin, imax, half_len = <span class="number">0</span>, m, (m + n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> imin &lt;= imax:</span><br><span class="line">        i = (imin + imax) // <span class="number">2</span></span><br><span class="line">        j = half_len - i</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums1[i - <span class="number">1</span>] &gt; nums2[j]:</span><br><span class="line">            imax = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> i &lt; m <span class="keyword">and</span> nums1[i] &lt; nums2[j - <span class="number">1</span>]:</span><br><span class="line">            imin = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                max_of_left = nums2[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">                max_of_left = nums1[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_of_left = <span class="built_in">max</span>(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> max_of_left</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i == m:</span><br><span class="line">                min_of_right = nums2[j]</span><br><span class="line">            <span class="keyword">elif</span> j == n:</span><br><span class="line">                min_of_right = nums1[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                min_of_right = <span class="built_in">min</span>(nums1[i], nums2[j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (max_of_left + min_of_right) / <span class="number">2.</span></span><br></pre></td></tr></table></figure>

<h1 id="longestPalindrome-dp-O-N-2"><a href="#longestPalindrome-dp-O-N-2" class="headerlink" title="longestPalindrome (dp) O(N^2)"></a>longestPalindrome (dp) O(N^2)</h1><img src="3.png" style="width:800px;"/>

<p>We set two indexes,’i’ and ‘j’, i to indicate the length of slide window, j to indicate the start of slide window, the dp formular is:</p>
<blockquote>
<p>P(i, j) &#x3D; P(i+1, j-1) + 2, if s[i] &#x3D;&#x3D; s[j].</p>
</blockquote>
<p>Note: </p>
<ul>
<li>P(i, i) &#x3D; 1</li>
<li>since ‘aa’ is also palindrome, so for P(i, i+1) &#x3D; 2 if s[i] &#x3D; s[i+1]</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n^2)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">    ret = <span class="string">&quot;&quot;</span></span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    <span class="comment"># i is the length, j is the start position</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-i+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># case 1, single char</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                dp[i][j] = <span class="number">1</span></span><br><span class="line">            <span class="comment"># case 2, continuous smae char</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> s[j] == s[j+<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> dp[i-<span class="number">2</span>][j+<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[j] == s[j+i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">2</span>][j+<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][j] &gt; max_len:</span><br><span class="line">                max_len = dp[i][j]</span><br><span class="line">                ret = s[j:j+i]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="isMatch-recursive-with-memo-O-MN"><a href="#isMatch-recursive-with-memo-O-MN" class="headerlink" title="isMatch (recursive with memo) O(MN)"></a>isMatch (recursive with memo) O(MN)</h1><img src="4.png" style="width:800px;"/>

<p>We can add memory to avoid repeated check.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s, p</span>):</span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">i, j</span>):</span><br><span class="line">        <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">if</span> j == n:</span><br><span class="line">                ans = i == m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                first_match = i &lt; m <span class="keyword">and</span> p[j] <span class="keyword">in</span> (s[i], <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> j + <span class="number">1</span> &lt; n <span class="keyword">and</span> p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    ans = recursive(</span><br><span class="line">                        i, j + <span class="number">2</span>) <span class="keyword">or</span> first_match <span class="keyword">and</span> recursive(i + <span class="number">1</span>, j)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans = first_match <span class="keyword">and</span> recursive(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">            memo[i, j] = ans</span><br><span class="line">        <span class="keyword">return</span> memo[i, j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h1 id="maxArea-trick-O-n"><a href="#maxArea-trick-O-n" class="headerlink" title="maxArea (trick) O(n)"></a>maxArea (trick) O(n)</h1><img src="5.png" style="width:800px;"/>

<p>We set i &#x3D; 0, and j &#x3D; len(heights), each time, we move the shorter height to find a higher height, and recalculate the max area. Beceuase if the next height is shorter than current height, it also has a short length on x-axis, it cannot have a larger volumn.</p>
<p>Note: we cannot use dp, since this problem doesn’t have the optimal sub-structure.</p>
<p>This trick works, because we fasten the i and j from the outside to inside, the width will decrease, only if the height increase, there may exist a larger area. And why we move the shorter height, because, if we fix the shorter height, and move the higher height, the min height still is the shorter height, the max area will only decrease with the width.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">height</span>):</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">    ret = <span class="built_in">min</span>(height[j], height[i]) * (j-i)</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, <span class="built_in">min</span>(height[i], height[j]) * (j-i))</span><br><span class="line">        <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="mark-threeSum-trick-O-n-2"><a href="#mark-threeSum-trick-O-n-2" class="headerlink" title="(mark) threeSum (trick) O(n^2)"></a>(mark) threeSum (trick) O(n^2)</h1><img src="6.png" style="width:800px;"/>

<p>We firstly sort the array, and then set three indexes, the first one is i, after we fix the i, we set j at the i+1, and k at the n-1, then we want the sum(s[j], s[k]) is -s[i], if the sum is less, we move the j&#x3D;j+1, else if the sum is larger, we move the k&#x3D;k-1(since the array is sorted).</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n^2) sort</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    nums.sort()</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="comment"># avoid repeat</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        j, k = i+<span class="number">1</span>, n-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; k:</span><br><span class="line">            s = nums[i] + nums[j] + nums[k]</span><br><span class="line">            <span class="keyword">if</span> s &lt; <span class="number">0</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]: <span class="comment"># avoid repeat</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k-<span class="number">1</span>]: <span class="comment"># avoid repeat</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="letterCombinations-full-permutation-O-3-N-4-M"><a href="#letterCombinations-full-permutation-O-3-N-4-M" class="headerlink" title="letterCombinations (full permutation), O(3^N * 4^M)"></a>letterCombinations (full permutation), O(3^N * 4^M)</h1><img src="7.png" style="width:800px;"/>

<p>Just use recursive, within the function, use while to iterate all possible chars to call recursive function.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">phone = &#123;<span class="string">&#x27;2&#x27;</span>: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;3&#x27;</span>: [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;4&#x27;</span>: [<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;5&#x27;</span>: [<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;6&#x27;</span>: [<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;7&#x27;</span>: [<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;8&#x27;</span>: [<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>],</span><br><span class="line">         <span class="string">&#x27;9&#x27;</span>: [<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">digits</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">prefix, digits</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            ret.append(prefix)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> phone[digits[<span class="number">0</span>]]:</span><br><span class="line">                recursion(prefix+c, digits[<span class="number">1</span>:])</span><br><span class="line">    recursion(<span class="string">&quot;&quot;</span>, digits)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="removeNthFromEnd-trick-O-n"><a href="#removeNthFromEnd-trick-O-n" class="headerlink" title="removeNthFromEnd (trick) O(n)"></a>removeNthFromEnd (trick) O(n)</h1><img src="8.png" style="width:800px;"/>

<p>We use two indexes, I and j, and we let the I firstly move forward n steps, and then we move these two indexes together, once the I reach the end, the j is at last n-th node.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">head, n</span>):</span><br><span class="line">    t = ListNode(<span class="literal">None</span>)</span><br><span class="line">    t.<span class="built_in">next</span> = head</span><br><span class="line">    p = t</span><br><span class="line">    q = t</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> p.<span class="built_in">next</span>:</span><br><span class="line">        q = q.<span class="built_in">next</span></span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line">    q.<span class="built_in">next</span> = q.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="generateParenthesis-recursive-O-4-n-√2"><a href="#generateParenthesis-recursive-O-4-n-√2" class="headerlink" title="generateParenthesis (recursive) O(4^n&#x2F;√2)"></a>generateParenthesis (recursive) O(4^n&#x2F;√2)</h1><img src="9.png" style="width:800px;"/>

<p>We use a count n to record the remaining available left parentheses, and another count k to record the assigned left parentheses.<br>-	if n &#x3D;&#x3D; 0 and k &#x3D;&#x3D; 0, output<br>-	If n &#x3D;&#x3D; 0 and k&gt;0, recursive(n, k-1), add ‘)’<br>-	If n &gt; 0 and k &#x3D;&#x3D; 0, recursive(n-1, k+1), add ‘(’<br>-	else we should try two directions: recursive(n-1, k+1), add ‘(’, and recursive(n, k-1), add ‘)’</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">n</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">prefix, i, j</span>):</span><br><span class="line">        <span class="comment"># i means the assigned number of &quot;(&quot; and don&#x27;t have &quot;)&quot;</span></span><br><span class="line">        <span class="comment"># j means the available number of &quot;(&quot;</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">            ret.append(prefix)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">            recursion(prefix+<span class="string">&quot;(&quot;</span>, i+<span class="number">1</span>, j-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">            recursion(prefix+<span class="string">&quot;)&quot;</span>, i-<span class="number">1</span>, j)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            recursion(prefix+<span class="string">&quot;(&quot;</span>, i+<span class="number">1</span>, j-<span class="number">1</span>)</span><br><span class="line">            recursion(prefix+<span class="string">&quot;)&quot;</span>, i-<span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">    recursion(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, n)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="nextPermutation-trick-O-n"><a href="#nextPermutation-trick-O-n" class="headerlink" title="nextPermutation (trick), O(n)"></a>nextPermutation (trick), O(n)</h1><img src="10.png" style="width:800px;"/>

<p>We set j&#x3D;len(n)-1, and set i&#x3D;len(n)-2, we search the i from end to start, once we found n[i] &lt; n[j], we swop n[i] and n[j], then we reverse n[i:j+1]</p>
<p>Note, from the last value, once we find a smaller value, we reverse all values between these two values.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    i = n - <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i + <span class="number">1</span>] &lt;= nums[i]:</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &lt;= nums[i]:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[i + <span class="number">1</span>:] = nums[:i:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nums[::] = nums[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="longestValidParentheses"><a href="#longestValidParentheses" class="headerlink" title="longestValidParentheses"></a>longestValidParentheses</h1><img src="11.png" style="width:800px;"/>

<h2 id="longestValidParentheses-stack-trick-O-n"><a href="#longestValidParentheses-stack-trick-O-n" class="headerlink" title="longestValidParentheses (stack trick) O(n)"></a>longestValidParentheses (stack trick) O(n)</h2><p>The idea behind this problem is, when we find a ‘)’ (stack is not empty), we need to check where does this start. So we record the position in the stack.</p>
<p>Once we encounter an invalid char(still need pop), or we has a ‘(’ now, we push its position into the stack, after that, when we encounter a “)”, we firstly pop a value from the stack, then we can always found the start point of the valid sub-path at the stack[-1].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s</span>):</span><br><span class="line">    max_ret = <span class="number">0</span></span><br><span class="line">    stack = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">                stack.append(i) <span class="comment"># last invalid point</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_ret = <span class="built_in">max</span>(max_ret, i - stack[-<span class="number">1</span>]) <span class="comment"># i-stack[-1] is current valid length</span></span><br><span class="line">    <span class="keyword">return</span> max_ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># dp O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s</span>):</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                dp[i] = (dp[i - <span class="number">2</span>] <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span> + \</span><br><span class="line">                    (dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>] <span class="keyword">if</span> i-dp[i-<span class="number">1</span>]-<span class="number">2</span> &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, dp[i])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h2 id="mark-longestValidParentheses-dp-O-n"><a href="#mark-longestValidParentheses-dp-O-n" class="headerlink" title="(mark) longestValidParentheses (dp) O(n)"></a>(mark) longestValidParentheses (dp) O(n)</h2><p>the i-th element of dp arary indicates the length of the longest valid substring ending at i-th index. And because the valid substing always ends with ‘)’, we will have:<br>-	s[i-1,i] &#x3D; ‘()’, dp[i] &#x3D; dp[i-2]+2, (dp[i-1]&#x3D;0)<br>-	s[i-1,i] &#x3D; ‘))’, we need to check s[i-dp[i-1]-1], the last char before the longest substring ending at [i-1] whether is ‘(’, if it is, dp[i] &#x3D; dp[i-1] + dp[i-dp[i-1]-2]+2, the longest substing a [i-1] + substring before last valid substring + 2.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s</span>):</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(s[i], i, dp[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> s[i-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                dp[i] = (dp[i-<span class="number">2</span>] <span class="keyword">if</span> i &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>) + <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> i-dp[i-<span class="number">1</span>] &gt; <span class="number">0</span> <span class="keyword">and</span> s[i-dp[i-<span class="number">1</span>]-<span class="number">1</span>] == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">2</span> + \</span><br><span class="line">                    (dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>] <span class="keyword">if</span> i-dp[i-<span class="number">1</span>]-<span class="number">2</span> &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, dp[i])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h1 id="mark-search-binary-search-trick-O-log-n"><a href="#mark-search-binary-search-trick-O-log-n" class="headerlink" title="(mark) search (binary search trick) O(log n)"></a>(mark) search (binary search trick) O(log n)</h1><img src="12.png" style="width:800px;"/>

<p>For example, we take [4, 5, 6, 7, 0, 1, 2] as input, and s&#x3D;0, e&#x3D;n-1, m&#x3D;(s+e)&#x2F;&#x2F;2</p>
<p>We make these four assumptions:<br>-	the axis locates at right, and target is at left: nums[s] &lt;&#x3D; target &lt; nums[m] -&gt; recursive(s, m-1)<br>-	the axis locates at left, and target is at right: nums[m] &lt; target &lt;&#x3D; nums[e] -&gt; recursive(s+1, m)<br>-	the axis locates at right, and target is at right: nums[m] &gt; nums[e]  -&gt; recursive(m+1, e)<br>-	the axis locates at left, and target is at left: nums[s] &gt; nums[m] -&gt; recursive(s, m-1)</p>
<p>For third case, there is a hidden condition, , if nums[m] &gt; nums[e], this means the axis locates at right, so the nums[s] must be less than nums[m], at this condition, we only need to check the target if it locates at the right, since if the target locates at left, this case will be the first case. The same idea for fourth case.</p>
<p>Besides, the recursion doesn’t break the rules of rotated list.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">i, j</span>):</span><br><span class="line">        <span class="keyword">if</span> j &lt; i:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        m = (i+j)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        <span class="comment"># target locates at non-axis side (and is left side)</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] &lt;= target &lt; nums[m]:</span><br><span class="line">            <span class="keyword">return</span> recursion(i, m-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># target locates at non-axis side (and is right side)</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &lt; target &lt;= nums[j]:</span><br><span class="line">            <span class="keyword">return</span> recursion(m+<span class="number">1</span>, j)</span><br><span class="line">        <span class="comment"># target locates at axis side (and is right side)</span></span><br><span class="line">        <span class="keyword">elif</span> nums[m] &gt; nums[j]:</span><br><span class="line">            <span class="keyword">return</span> recursion(m+<span class="number">1</span>, j)</span><br><span class="line">        <span class="comment"># target locates at axis side (and is left side)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> recursion(i, m-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> recursion(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="searchRange-Binary-Search-trick-O-log-n"><a href="#searchRange-Binary-Search-trick-O-log-n" class="headerlink" title="searchRange (Binary Search trick) O(log n)"></a>searchRange (Binary Search trick) O(log n)</h1><img src="13.png" style="width:800px;"/>

<p>we use two binary search, one search the left boundary and another for the right boundary.</p>
<p>We modify the original binary search, make it to continue search when we found the target value. Also, once right_index <code>&lt;</code>left_index, we return left_index for the left boundary search, and return right_index for the right one.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, target</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursiveLeft</span>(<span class="params">s, e</span>):</span><br><span class="line">        <span class="keyword">if</span> e &lt; s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        m = (s+e)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> recursiveLeft(m+<span class="number">1</span>, e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> recursiveLeft(s, m-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursiveRight</span>(<span class="params">s, e</span>):</span><br><span class="line">        <span class="keyword">if</span> e &lt; s:</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">        m = (s+e)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt;= target:</span><br><span class="line">            <span class="keyword">return</span> recursiveRight(m+<span class="number">1</span>, e)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> recursiveRight(s, m-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    left, right = recursiveLeft(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>), recursiveRight(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># once we cannot found the value, the left will right-1</span></span><br><span class="line">    <span class="keyword">return</span> [left, right] <span class="keyword">if</span> left &lt;= right <span class="keyword">else</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="combinationSum-dfs-O-exponential"><a href="#combinationSum-dfs-O-exponential" class="headerlink" title="combinationSum (dfs) O(exponential)"></a>combinationSum (dfs) O(exponential)</h1><img src="14.png" style="width:800px;"/>

<p>just add a loop to call the recursion function.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">candidates, target</span>):</span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">prefix, i, target</span>):</span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            ret.append(prefix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            num = candidates[i]</span><br><span class="line">            <span class="keyword">if</span> target - num &gt;= <span class="number">0</span>:</span><br><span class="line">                recursion(prefix+[num], i, target-num)</span><br><span class="line">    recursion([], <span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="firstMissingPositive-trick-hash-with-mod-position-O-n"><a href="#firstMissingPositive-trick-hash-with-mod-position-O-n" class="headerlink" title="firstMissingPositive (trick: hash with mod position) O(n)"></a>firstMissingPositive (trick: hash with mod position) O(n)</h1><img src="15.png" style="width:800px;"/>

<p>The biggest challenge is, we can only use extra constant space which means we cannot set up a hash table with O(n) space. So the solution use the input array as the has table. </p>
<p>Using: nums[nums[i] % n] +&#x3D; n(first to handle all &lt;0 or &gt;&#x3D;n to 0), this to mark a bin has been covered, after iterating all values, we can check the value which less than n, the first value we found is the final result.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    nums.append(<span class="number">0</span>) <span class="comment"># very important, for example, [1]</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># delete those useless elements</span></span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> <span class="keyword">or</span> nums[i] &gt;= n:</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># use the index as the hash to record the frequency of each number</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        nums[nums[i] % n] += n <span class="comment"># +n and %n to make the original value do not be overlaped</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; n:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>

<h1 id="Trap-two-dp-left-and-right-O-n"><a href="#Trap-two-dp-left-and-right-O-n" class="headerlink" title="Trap (two dp, left and right) O(n)"></a>Trap (two dp, left and right) O(n)</h1><img src="16.png" style="width:800px;"/>

<p>We use two dp, to record both max heights from left and right respectively.<br>-	dp_l[i] &#x3D; max(dp_l[i-1], height[i])<br>-	dp_r[i] &#x3D; max(dp_r[i+1], height[i])</p>
<p>Then, each bin’s water volume is: min(dp_l[i], dp_r[i]) - height[i].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">height</span>):</span><br><span class="line">    height = [<span class="number">0</span>] + height + [<span class="number">0</span>]</span><br><span class="line">    n = <span class="built_in">len</span>(height)</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    max_left = [<span class="number">0</span>] * n  <span class="comment"># record the max height from left</span></span><br><span class="line">    max_right = [<span class="number">0</span>] * n  <span class="comment"># record the max height from right</span></span><br><span class="line">    cur_max = height[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        cur_max = <span class="built_in">max</span>(cur_max, height[i])</span><br><span class="line">        max_left[i] = cur_max</span><br><span class="line">    cur_max = height[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        cur_max = <span class="built_in">max</span>(cur_max, height[i])</span><br><span class="line">        max_right[i] = cur_max</span><br><span class="line">        ret += <span class="built_in">min</span>(max_left[i], max_right[i]) - height[i]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>


<h1 id="Permute-loop-call-recusive-O-2-n"><a href="#Permute-loop-call-recusive-O-2-n" class="headerlink" title="Permute (loop call recusive) O(2^n)"></a>Permute (loop call recusive) O(2^n)</h1><img src="17.png" style="width:800px;"/>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">prefix, remaining</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> remaining:</span><br><span class="line">            ret.append(prefix)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(remaining)):</span><br><span class="line">                recursion(prefix+[remaining[k]], remaining[:k] + remaining[k+<span class="number">1</span>:])</span><br><span class="line">    recursion([], nums)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="Rotate-trick-O-n-2"><a href="#Rotate-trick-O-n-2" class="headerlink" title="Rotate (trick) O(n^2)"></a>Rotate (trick) O(n^2)</h1><img src="18.png" style="width:800px;"/>

<p>First reverse and then transpose</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">matrix</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(matrix)</span><br><span class="line">    i, j = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">    <span class="comment"># swap</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        matrix[i], matrix[j] = matrix[j], matrix[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        j -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># transpose</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>

<h1 id="mark-groupAnagrams-hash-O-m"><a href="#mark-groupAnagrams-hash-O-m" class="headerlink" title="(mark) groupAnagrams (hash) O(m)"></a>(mark) groupAnagrams (hash) O(m)</h1><img src="19.png" style="width:800px;"/>

<p>using collections.defaultdict(list), take the tuple(sorted(s)) as the key of hash table.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">strs</span>):</span><br><span class="line">    ret = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">        ret[<span class="built_in">tuple</span>(<span class="built_in">sorted</span>(s))].append(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(ret.values())</span><br></pre></td></tr></table></figure>

<p>** sorted(s) is ok but set(s) cannot.</p>
<h1 id="mark-maxSubArray-trick-O-n"><a href="#mark-maxSubArray-trick-O-n" class="headerlink" title="(mark) maxSubArray (trick) O(n)"></a>(mark) maxSubArray (trick) O(n)</h1><img src="20.png" style="width:800px;"/>

<p>We scan the array from the left to right, we use a list to record the accumulated sum, only if the left sum is positive, we use it, otherwise, this negative value should be discarded. </p>
<p>So the sum is: nums[i] &#x3D; max(0, nums[i-1]) + nums[i]</p>
<p>For each continue positve sub-list, we compare to record the maximum sum: ret &#x3D; max(ret, nums[i]).</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    cur_sum = <span class="number">0</span></span><br><span class="line">    max_v = - sys.maxsize</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        cur_sum = <span class="built_in">max</span>(<span class="number">0</span>, cur_sum) + num</span><br><span class="line">        max_v = <span class="built_in">max</span>(max_v, cur_sum)</span><br><span class="line">    <span class="keyword">return</span> max_v</span><br></pre></td></tr></table></figure>

<h1 id="canJump-greedy-O-n"><a href="#canJump-greedy-O-n" class="headerlink" title="canJump (greedy) O(n)"></a>canJump (greedy) O(n)</h1><img src="21.png" style="width:800px;"/>

<p>We scan the list from the left to right up to the farest value we can reach, each time once we get a new value, we modify the farest value, so if we can attend the final position, return true, otherwise return false.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    m = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> i &gt; m:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        m = <span class="built_in">max</span>(m, i+nums[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    i, max_i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= max_i <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> max_i &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span>:</span><br><span class="line">        max_i = <span class="built_in">max</span>(max_i, i+nums[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> max_i &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="merge-greedy-O-n"><a href="#merge-greedy-O-n" class="headerlink" title="merge (greedy) O(n)"></a>merge (greedy) O(n)</h1><img src="22.png" style="width:800px;"/>

<p>We firstly sort the input, then using a list, add the first tuple into the list, each time check whether the last tuple’s right value is larger than the second tuple’s first value, if yes, we merge this two, else only insert the tuple into the list.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    merged = []</span><br><span class="line">    <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merged <span class="keyword">or</span> merged[-<span class="number">1</span>][<span class="number">1</span>] &lt; interval[<span class="number">0</span>]:</span><br><span class="line">            merged.append(interval)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merged[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(merged[-<span class="number">1</span>][<span class="number">1</span>], interval[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">intervals</span>):</span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">while</span> intervals:</span><br><span class="line">        interval_1 = intervals.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> intervals <span class="keyword">and</span> interval_1[<span class="number">1</span>] &gt;= intervals[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            intervals[<span class="number">0</span>][<span class="number">0</span>] = interval_1[<span class="number">0</span>]</span><br><span class="line">            intervals[<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[<span class="number">0</span>][<span class="number">1</span>], interval_1[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret.append(interval_1)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="uniquePaths-dp-O-m-n"><a href="#uniquePaths-dp-O-m-n" class="headerlink" title="uniquePaths (dp) O(m+n)"></a>uniquePaths (dp) O(m+n)</h1><img src="23.png" style="width:800px;"/>

<p><code>dp[i][j] = dp[i][j-1] + dp[i-1][j]</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">m, n</span>):</span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][j] = dp[i][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j]</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="minPathSum-dp-O-mn"><a href="#minPathSum-dp-O-mn" class="headerlink" title="minPathSum (dp) O(mn)"></a>minPathSum (dp) O(mn)</h1><img src="24.png" style="width:800px;"/>

<p><code>dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + m[i][j]</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">grid</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] + grid[<span class="number">0</span>][j]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + grid[i][j]</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="climbStairs-dp-O-n"><a href="#climbStairs-dp-O-n" class="headerlink" title="climbStairs (dp) O(n)"></a>climbStairs (dp) O(n)</h1><img src="25.png" style="width:800px;"/>

<p><code>dp[i] = dp[i-1] + dp[i-2], dp[0]=1, dp[1] = 1</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="mark-minDistance-dc-O-mn"><a href="#mark-minDistance-dc-O-mn" class="headerlink" title="(mark) minDistance (dc) O(mn)"></a>(mark) minDistance (dc) O(mn)</h1><img src="26.png" style="width:800px;"/>

<p>We define a recursive function: recursive(word1, word2, i, j, memo), which returns the amount of operations for word1[i:] and word2[j:], and we use memo to record the sub-problem. </p>
<p>For the word1[i] and word2[j], if they are equal, we make memo[i][j] &#x3D; recursive(word1, word2, i+1, j+1, memo). Else, we define these three operations:<br>-	insert &#x3D; 1 + recursive(word1, word2, i, j+1, memo), we insert word2[j] before word1[i], so they are eaqual, then we compare word1[i] with word2[j+1].<br>-	delete &#x3D; 1 + recursive(word1, word2, i+1, j, memo), we delete word2[j], then we compare word1[i+1] with word2[j].<br>-	replace &#x3D; 1 + recursive(word1, word2, i+1, j+1, memo), we replace word1[i] with word2[j], so they are equal, so we continue to compare word1[i+1] with word2[j+1].</p>
<p>and make memo[i][j] &#x3D; min(insert, delete, replace).</p>
<p>For the termination of the recursion, when i&#x3D;m, j&#x3D;n, it means we’ve handled all words, so return 0, else, when i&#x3D;m, we return n-j, when i&#x3D;n, we return m-i, since if we’ve already handled one word, we only need to insert the remaining chars in another word.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">word1, word2</span>):</span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    n, m = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">    <span class="keyword">if</span> m &lt; n:</span><br><span class="line">        word1, word2, m, n = word2, word1, n, m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">i, j</span>):</span><br><span class="line">        <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans = m - j</span><br><span class="line">            <span class="keyword">elif</span> j == m:</span><br><span class="line">                ans = n - i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> word1[i] == word2[j]:</span><br><span class="line">                    ans = recursive(i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># insert, delete, replace</span></span><br><span class="line">                    ans = <span class="built_in">min</span>(recursive(i, j + <span class="number">1</span>), recursive(i + <span class="number">1</span>, j),</span><br><span class="line">                              recursive(i + <span class="number">1</span>, j + <span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">            memo[i, j] = ans</span><br><span class="line">        <span class="keyword">return</span> memo[i, j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h1 id="sortColors-trick-O-n"><a href="#sortColors-trick-O-n" class="headerlink" title="sortColors (trick) O(n)"></a>sortColors (trick) O(n)</h1><img src="27.png" style="width:800px;"/>

<p>We use three indexes, i, j, k, the i and j indicate the range that we need to handle, and k indicates the value we are handling. For the nums[k], there are three cases:<br>-	nums[k] &#x3D;&#x3D; 0, we swap nums[i] and nums[k], then i+&#x3D;1, k+&#x3D;1.<br>-	nums[k] &#x3D;&#x3D; 1, do nothing, just k+&#x3D;1<br>-	nums[k] &#x3D;&#x3D; 2, we swap nums[j] and nums[k], then j-&#x3D;1.</p>
<p>Actually, the i indicates the end of “0” values, the j for start of “2” values, each time, we encounter a “0”, we swap it to the end of “0” values, and for “2” values, we swap it to the start of “2” values, so at final, the middle are all “1” values.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    i, j, k = <span class="number">0</span>, <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= k:</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">            nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h1 id="minWindow-trick-hash-O-n"><a href="#minWindow-trick-hash-O-n" class="headerlink" title="minWindow (trick hash) O(n)"></a>minWindow (trick hash) O(n)</h1><img src="28.png" style="width:800px;"/>

<p>We use two indexes i and j to indicate the start and end of the slide window. We also use a hash table to count amout of each char in T. The hash tbale m looks like a balance wallet, we first add chars of T into it, then once we encounter chars in S, we minus from m. So for m&gt;0 means there is still char we need to find, and m&lt;0 means we remove much more than we need in T. We also use a count&#x3D;len(T) to identify whether we have encounter all chars within T. First, we move the i to right, and we minus one from hash table m[s[i]], and we only minus one from count if we found m[s[i]]&gt;0(means we remove a target char), which means there are still uncount chars within T(because we may encounter several same chars, so the m[s[i]] could be negative, but for that time, we won’t minus from count). Once count equals to zero, we move j to right, each time we add one to m[s[i]], and we add one to count if we found m[s[i]]&gt;0, which means there are still uncount chars within T again.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minWindow</span>(<span class="params">self, s, t</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :type t: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    m = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># m just like a balance wallet</span></span><br><span class="line">    <span class="comment"># we first add chars of T into it</span></span><br><span class="line">    <span class="comment"># then once we encounter chars in S</span></span><br><span class="line">    <span class="comment"># we minus from m</span></span><br><span class="line">    <span class="comment"># so for m&gt;0 menas there is still char we need to find</span></span><br><span class="line">    <span class="comment"># m&lt;0 means we remove much more than we need in T</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">        m[c] += <span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># identify how many remaining chars in T we still need to find</span></span><br><span class="line">    count = <span class="built_in">len</span>(t)</span><br><span class="line">    minLen = sys.maxsize</span><br><span class="line">    minStart = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># only when m[s[i]] &gt; 0, means remaining chars in t</span></span><br><span class="line">        <span class="keyword">if</span> m[s[i]] &gt; <span class="number">0</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">        m[s[i]] -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># we have found all chars in T, we start to move j</span></span><br><span class="line">        <span class="keyword">while</span> count == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (i - j + <span class="number">1</span>) &lt; minLen:</span><br><span class="line">                minLen = i-j+<span class="number">1</span></span><br><span class="line">                minStart = j</span><br><span class="line">            m[s[j]] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># when m[s[i]] &gt; 0, means we remove too much target chars</span></span><br><span class="line">            <span class="comment"># we increase count to mark there are chars we need to find</span></span><br><span class="line">            <span class="keyword">if</span> m[s[j]] &gt; <span class="number">0</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> minLen &lt; sys.maxsize:</span><br><span class="line">        <span class="keyword">return</span> s[minStart:minStart+minLen]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    c_t = Counter(t)</span><br><span class="line">    count = <span class="built_in">len</span>(t)</span><br><span class="line">    b, l = <span class="number">0</span>, sys.maxsize</span><br><span class="line">    <span class="keyword">while</span> j &lt; n:</span><br><span class="line">        <span class="keyword">if</span> c_t[s[j]] &gt; <span class="number">0</span>:</span><br><span class="line">            count -= <span class="number">1</span></span><br><span class="line">        c_t[s[j]] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> count:</span><br><span class="line">            <span class="keyword">if</span> (j-i+<span class="number">1</span>) &lt; l:</span><br><span class="line">                l = j-i+<span class="number">1</span></span><br><span class="line">                b = i</span><br><span class="line">            c_t[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c_t[s[i]] &gt; <span class="number">0</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; sys.maxsize:</span><br><span class="line">        <span class="keyword">return</span> s[b:b+l]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>


<h1 id="Subsets-dfs-O-2-n"><a href="#Subsets-dfs-O-2-n" class="headerlink" title="Subsets (dfs) O(2^n)"></a>Subsets (dfs) O(2^n)</h1><img src="29.png" style="width:800px;"/>

<p>Same with permutation, but also output at intermediate nodes.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">prefix, i</span>):</span><br><span class="line">        ret.append(prefix)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            recursion(prefix+[nums[j]], j+<span class="number">1</span>)</span><br><span class="line">    recursion([], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="mark-Exist-dfs-O-mn-len-words"><a href="#mark-Exist-dfs-O-mn-len-words" class="headerlink" title="(mark) Exist (dfs) O(mn * len(words))"></a>(mark) Exist (dfs) O(mn * len(words))</h1><img src="30.png" style="width:800px;"/>

<p>We dedine a recursive function: dfs(row, col, idx), means from nums[row][col] starts finding word[idx:]. We iterative all cells, and only call dfs from the cell which equals to word[0].</p>
<p>Within the recursive function. If idx &#x3D;&#x3D; len(word), return True, else we check four directions, if it equals to word[idx], we call recursive func, if all fail, return false.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">board, word</span>):</span><br><span class="line">    m, n = <span class="built_in">len</span>(board), <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">i, j, idx</span>):</span><br><span class="line">        <span class="keyword">if</span> idx == <span class="built_in">len</span>(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        board[i][j] = <span class="string">&quot;#&quot;</span></span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> &lt; m <span class="keyword">and</span> board[i+<span class="number">1</span>][j] == word[idx] <span class="keyword">and</span> recursion(i+<span class="number">1</span>, j, idx+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> j+<span class="number">1</span> &lt; n <span class="keyword">and</span> board[i][j+<span class="number">1</span>] == word[idx] <span class="keyword">and</span> recursion(i, j+<span class="number">1</span>, idx+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> i-<span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> board[i-<span class="number">1</span>][j] == word[idx] <span class="keyword">and</span> recursion(i-<span class="number">1</span>, j, idx+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> j-<span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> board[i][j-<span class="number">1</span>] == word[idx] <span class="keyword">and</span> recursion(i, j-<span class="number">1</span>, idx+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        board[i][j] = word[idx-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> board[i][j] == word[<span class="number">0</span>] <span class="keyword">and</span> recursion(i, j, <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="largestRectangleArea-left-and-right-dp-O-n"><a href="#largestRectangleArea-left-and-right-dp-O-n" class="headerlink" title="largestRectangleArea (left and right dp) O(n)"></a>largestRectangleArea (left and right dp) O(n)</h1><img src="31.png" style="width:800px;"/>

<p>We use two array, left_min and right_min to record the position of first smaller value from left and right, so each rectangle’s area is: height[i] * (right_min[i] - left_min[i] -1)</p>
<p>We set left_min[0]&#x3D;-1, for left_min[i], we search from j&#x3D;i-1, each time we found height[j] &gt;&#x3D; height[i], we set j&#x3D;left_min[j] to recursively find the first smaller value.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">heights</span>):</span><br><span class="line">    heights = [<span class="number">0</span>] + heights + [<span class="number">0</span>]</span><br><span class="line">    n = <span class="built_in">len</span>(heights)</span><br><span class="line">    min_left = [<span class="number">0</span>] * n</span><br><span class="line">    min_right = [<span class="number">0</span>] * n</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        tmp_i = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tmp_i &gt; <span class="number">0</span> <span class="keyword">and</span> heights[tmp_i] &gt;= heights[i]:</span><br><span class="line">            tmp_i = min_left[tmp_i]</span><br><span class="line">        min_left[i] = tmp_i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        tmp_j = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tmp_j &lt; n - <span class="number">1</span> <span class="keyword">and</span> heights[tmp_j] &gt;= heights[j]:</span><br><span class="line">            tmp_j = min_right[tmp_j]</span><br><span class="line">        min_right[j] = tmp_j</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, heights[i] * (min_right[i] - min_left[i] - <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="maximalRectangle-greedy-O-mn"><a href="#maximalRectangle-greedy-O-mn" class="headerlink" title="maximalRectangle (greedy) O(mn)"></a>maximalRectangle (greedy) O(mn)</h1><img src="32.png" style="width:800px;"/>

<p>We use three arrays to record the most far height, left boundary and right boundary.</p>
<p>For height:<br>-	if matrix[i][j] &#x3D;&#x3D; ‘1’: height[j] +&#x3D; 1, else height[j] &#x3D; 0</p>
<p>For left:<br>-	if matrix[i][j] &#x3D;&#x3D; ‘1’: left[j] &#x3D; max(left[j], cur_left), else left[j] &#x3D; 0, cur_left &#x3D; j+1</p>
<p>For right:<br>-	if matrix[i][j] &#x3D;&#x3D; ‘1’: right[j] &#x3D; min(right[j], cur_right), else right[j] &#x3D; n, cur_right &#x3D; j.</p>
<p>The precess is, firstly we determine the height of the rectangle, then we find the most far left boundary and right boundary of this rectangle. We use cur_left to record the far left boundary of this line, and left[j] to record the far boundary of all lines, so max(left[j], cur_left) gives us the most far left boundary of the rectangle in this line.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    left, right, height = [<span class="number">0</span>] * n, [n] * n, [<span class="number">0</span>] * n</span><br><span class="line">    max_v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        cur_left, cur_right = <span class="number">0</span>, n</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                height[j] += <span class="number">1</span></span><br><span class="line">                left[j] = <span class="built_in">max</span>(left[j], cur_left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                height[j] = <span class="number">0</span></span><br><span class="line">                left[j] = <span class="number">0</span></span><br><span class="line">                cur_left = j + <span class="number">1</span></span><br><span class="line">            j = n - j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                right[j] = <span class="built_in">min</span>(right[j], cur_right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right[j] = n</span><br><span class="line">                cur_right = j</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            max_v = <span class="built_in">max</span>(max_v, (right[j] - left[j]) * height[j])</span><br><span class="line">    <span class="keyword">return</span> max_v</span><br></pre></td></tr></table></figure>

<h1 id="inorderTraversal-iterative-O-n"><a href="#inorderTraversal-iterative-O-n" class="headerlink" title="inorderTraversal (iterative) O(n)"></a>inorderTraversal (iterative) O(n)</h1><img src="33.png" style="width:800px;"/>

<p>using a stack, each time pop a node, and push its children into the stack by this tuple (node.left, node.val, node.right), each time we found a value, we output it.</p>
<p>Another way: we firstly loop to push left node into the stack up to the most left leaf, each time we pop a node, ouput it, and add its left node recursively again.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line">    ret = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        recursion(root.left)</span><br><span class="line">        ret.append(root.val)</span><br><span class="line">        recursion(root.right)</span><br><span class="line">    recursion(root)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line">    ret = []</span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(node, <span class="built_in">int</span>):</span><br><span class="line">            ret.append(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.extend([node.right, node.val, node.left])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="numTrees-dp-O-n-2"><a href="#numTrees-dp-O-n-2" class="headerlink" title="numTrees (dp) O(n^2)"></a>numTrees (dp) O(n^2)</h1><img src="34.png" style="width:800px;"/>

<p>We need to define two functions:<br>-	G(n): the number of unique BST for a sequence of length n.<br>-	F(i, n), 1 &lt;&#x3D; i &lt;&#x3D; n: the number of unique BST, where the number i is the root of BST, and the sequence ranges from 1 to n.</p>
<p>So, G(n) &#x3D; F(1, n) + F(2, n) + … + F(n, n). And G(0)&#x3D;1, G(1)&#x3D;1.</p>
<p>We found that: F(i, n) &#x3D; G(i-1) * G(n-i).</p>
<p>Combining the above two formulas, we obtain the recursive formula for G(n). i.e.</p>
<p>G(n) &#x3D; G(0) * G(n-1) + G(1) * G(n-2) + … + G(n-1) * G(0).</p>
<p>So we start from G(2), G(2) &#x3D; G(0) * G(1), G(3) &#x3D; G(0) * G(2) + G(1) * G(1) + G(2) * G(0), …, finally we get G(n).</p>
<p>Firstly, I want to use 2D dp, but from the above solution, I found, we don’t care about the start point and end pint, we only care about the length of the sub-question. So we can only use 1D dp.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">n</span>):</span><br><span class="line">    dp = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">            dp[i] += (dp[j-<span class="number">1</span>]*dp[i-j])</span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="isValidBST-post-order-dfs-O-n"><a href="#isValidBST-post-order-dfs-O-n" class="headerlink" title="isValidBST (post-order, dfs) O(n)"></a>isValidBST (post-order, dfs) O(n)</h1><img src="35.png" style="width:800px;"/>

<p>The first solution, we compare from down to up, we get the max and min value of each subtree. So, for a valid node, its value must larger than max value of left subtree and less than min value of right subtree.</p>
<p>The second solution, we compare from up to down, we set a range by two value: low bound and upper bound, each time we enter a left tree, we constrict the upper bound, and when we enter the right tree, we constrict the right bound.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">root, min_v, max_v</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> root.val &lt;= min_v <span class="keyword">or</span> root.val &gt;= max_v:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> recursion(root.left, min_v, root.val) <span class="keyword">and</span> recursion(root.right, root.val, max_v)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursion(root.left, -sys.maxsize, root.val) <span class="keyword">and</span> recursion(root.right, root.val, sys.maxsize)</span><br></pre></td></tr></table></figure>

<h1 id="mark-isSymmetric-dfs-or-bfs-O-n"><a href="#mark-isSymmetric-dfs-or-bfs-O-n" class="headerlink" title="(mark) isSymmetric (dfs or bfs) O(n)"></a>(mark) isSymmetric (dfs or bfs) O(n)</h1><img src="36.png" style="width:800px;"/>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursion</span>(<span class="params">root1, root2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">and</span> <span class="keyword">not</span> root2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> root1 <span class="keyword">and</span> root2:</span><br><span class="line">            <span class="keyword">if</span> root1.val == root2.val:</span><br><span class="line">                <span class="keyword">return</span> recursion(root1.left, root2.right) <span class="keyword">and</span> recursion(</span><br><span class="line">                    root1.right, root2.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursion(root.left, root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    queue1 = [root.left, root.right]</span><br><span class="line">    queue2 = [root.right, root.left]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue1 <span class="keyword">and</span> queue2:</span><br><span class="line">        node1 = queue1.pop(<span class="number">0</span>)</span><br><span class="line">        node2 = queue2.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1 <span class="keyword">and</span> <span class="keyword">not</span> node2:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> node1 <span class="keyword">and</span> node2 <span class="keyword">and</span> node1.val == node2.val:</span><br><span class="line">            queue1.extend([node1.left, node1.right])</span><br><span class="line">            queue2.extend([node2.right, node2.left])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> queue1 <span class="keyword">and</span> <span class="keyword">not</span> queue2:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="mark-buildTree-recursive-O-n"><a href="#mark-buildTree-recursive-O-n" class="headerlink" title="(mark) buildTree (recursive) O(n)"></a>(mark) buildTree (recursive) O(n)</h1><img src="37.png" style="width:800px;"/>

<p>We found that the preorder indicates each root by the level order, and each root will recursively split the inorder into two part, its left and right subtree. </p>
<p>We use a dict to record the position of inorder in order to find the value quickly, then we define a function to construct the tree: def helper(start, end). Each time we give the function the range of its value in the inorder tree, then we recursively construct its left and right subtree as:<br>-	root.left &#x3D; helper(start, idx-1)<br>-	root.right &#x3D; helper(idx+1, end)</p>
<p>(if start &gt; end, return None)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">preorder, inorder</span>):</span><br><span class="line"></span><br><span class="line">    inorder_dict = &#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(inorder)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">i, j</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> i &gt; j:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        val = preorder.pop(<span class="number">0</span>)</span><br><span class="line">        key = inorder_dict[val]</span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        node.left = build(i, key - <span class="number">1</span>)</span><br><span class="line">        node.right = build(key + <span class="number">1</span>, j)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> build(<span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="mark-Flatten-iterative-pre-order-dfs-O-n"><a href="#mark-Flatten-iterative-pre-order-dfs-O-n" class="headerlink" title="(mark) Flatten (iterative pre-order dfs) O(n)"></a>(mark) Flatten (iterative pre-order dfs) O(n)</h1><img src="38.png" style="width:800px;"/>

<p>Each time we find the deepest left node, and insert it to its parent node’s first right node, then we enter the right node to do the same thing.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flatten</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            <span class="comment"># get the deepest left node to append to its first right node</span></span><br><span class="line">            tmp_node = flatten(node.left)</span><br><span class="line">            tmp_node.right = node.right <span class="comment"># append it right to the deepest node&#x27;s right</span></span><br><span class="line">            node.right = node.left <span class="comment"># append the top left to its right</span></span><br><span class="line">            node.left = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            <span class="comment"># return deepest right node</span></span><br><span class="line">            <span class="keyword">return</span> flatten(node.right)</span><br><span class="line"></span><br><span class="line">    flatten(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h1 id="maxProfit-trick-O-n"><a href="#maxProfit-trick-O-n" class="headerlink" title="maxProfit (trick) O(n)"></a>maxProfit (trick) O(n)</h1><img src="39.png" style="width:800px;"/>

<p>This problem is that, we want to find the tuple of [lowest, highest], and the highest value must appear after the lowest one. So we record the lowest, and each time we update:<br>-	lowest &#x3D; min(lowest, prices[i])<br>-	profit &#x3D; max(profit, prices[i]-lowest)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">prices</span>):</span><br><span class="line">    cur_min = sys.maxsize</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> prices:</span><br><span class="line">        cur_min = <span class="built_in">min</span>(cur_min, p)</span><br><span class="line">        max_profit = <span class="built_in">max</span>(max_profit, p - cur_min)</span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>

<h1 id="maxPathSum-tree-dp-O-n"><a href="#maxPathSum-tree-dp-O-n" class="headerlink" title="maxPathSum (tree dp) O(n)"></a>maxPathSum (tree dp) O(n)</h1><img src="40.png" style="width:800px;"/>

<p>From the bottom to up, at each node, we calculate the max value from left and max value from right, we try to update the result &#x3D; max(result, left_max+right_max+node.val), and for the return value, we return the max value from left_max+node.val and right_max+node.val, remember we need to compare with 0, since if the value less than 0, we actually delete it from the path. </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line">    max_v = -sys.maxsize</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> max_v</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = recursive(root.left)</span><br><span class="line">            right = recursive(root.right)</span><br><span class="line">            max_v = <span class="built_in">max</span>(max_v, left + right + root.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left + root.val, right + root.val, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    recursive(root)</span><br><span class="line">    <span class="keyword">return</span> max_v</span><br></pre></td></tr></table></figure>

<h1 id="longestConsecutive-hash-O-n"><a href="#longestConsecutive-hash-O-n" class="headerlink" title="longestConsecutive (hash) O(n)"></a>longestConsecutive (hash) O(n)</h1><img src="41.png" style="width:800px;"/>

<p>We convert the array to set(nums), when we iterate the array, we check whether the nums[i]-1 is in the array, if yes, skip. So once we found a smallest value, then try to check tmp_num+1 one by one, so we can get its consecutive length.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    set_nums = <span class="built_in">set</span>(nums)</span><br><span class="line">    max_v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> set_nums:</span><br><span class="line">            count = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> num + <span class="number">1</span> <span class="keyword">in</span> set_nums:</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            max_v = <span class="built_in">max</span>(max_v, count)</span><br><span class="line">    <span class="keyword">return</span> max_v</span><br></pre></td></tr></table></figure>

<h1 id="copyRandomList-hash-O-n"><a href="#copyRandomList-hash-O-n" class="headerlink" title="copyRandomList (hash) O(n)"></a>copyRandomList (hash) O(n)</h1><img src="42.png" style="width:800px;"/>

<p>we using collections.defaultdict to store nodes which has been visited.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">head</span>):</span><br><span class="line">    node_dict = defaultdict(Node)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">node</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        _node = Node(node.val)</span><br><span class="line">        node_dict[node] = _node</span><br><span class="line">        <span class="keyword">if</span> node.random:</span><br><span class="line">            <span class="keyword">if</span> node.random <span class="keyword">in</span> node_dict:</span><br><span class="line">                _node.random = node_dict[node.random]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _node.random = build(node.random)</span><br><span class="line">        <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span> <span class="keyword">in</span> node_dict:</span><br><span class="line">                _node.<span class="built_in">next</span> = node_dict[node.<span class="built_in">next</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _node.<span class="built_in">next</span> = build(node.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> _node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> build(head)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    node_dict = defaultdict(Node)</span><br><span class="line"></span><br><span class="line">    _head = Node(head.val)</span><br><span class="line">    node_dict[head] = _head</span><br><span class="line">    ret_head = _head</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        <span class="keyword">if</span> head.random:</span><br><span class="line">            <span class="keyword">if</span> head.random <span class="keyword">not</span> <span class="keyword">in</span> node_dict:</span><br><span class="line">                node_dict[head.random] = Node(head.random.val)</span><br><span class="line">            _head.random = node_dict[head.random]</span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> node_dict:</span><br><span class="line">                node_dict[head.<span class="built_in">next</span>] = Node(head.<span class="built_in">next</span>.val)</span><br><span class="line">            _head.<span class="built_in">next</span> = node_dict[head.<span class="built_in">next</span>]</span><br><span class="line">        head = head.<span class="built_in">next</span></span><br><span class="line">        _head = _head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret_head</span><br></pre></td></tr></table></figure>

<h1 id="wordbreak-dp-O-mn"><a href="#wordbreak-dp-O-mn" class="headerlink" title="wordbreak (dp) O(mn)"></a>wordbreak (dp) O(mn)</h1><img src="43.png" style="width:800px;"/>

<p>We set dp[i] as the result of s[0:i], and dp[i]&#x3D;true if dp[i-len(w)] and s[i-len(w):i] &#x3D;&#x3D; w.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s, wordDict</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    dp = [<span class="literal">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(w) <span class="keyword">and</span> dp[i - <span class="built_in">len</span>(w)] <span class="keyword">and</span> s[i - <span class="built_in">len</span>(w):i] == w:</span><br><span class="line">                dp[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="DetectCycle-trick-O-n"><a href="#DetectCycle-trick-O-n" class="headerlink" title="DetectCycle (trick) O(n)"></a>DetectCycle (trick) O(n)</h1><img src="44.png" style="width:800px;"/>

<p>Let the distance from the first node to the node where cycle begins be A, and let say the slow pointer travels A+B. The fast pointer must travel 2A+2B to catch up. The cycle size is N. Full cycle is also how much faster pointer has traveled than slow pointer at meeting point.<br>-	A+B+N &#x3D; 2A+2B<br>-	N&#x3D;A+B</p>
<p>So once meet, we make another pointer start from head, we move slow pointer and this pointer together, once they meet, we found the beginning node. (because B+A&#x3D;N).</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">head</span>):</span><br><span class="line">    p = head</span><br><span class="line">    q = head</span><br><span class="line">    t = head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">and</span> q <span class="keyword">and</span> p.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span> <span class="keyword">and</span> q.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        p = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        q = q.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> q == p:</span><br><span class="line">            <span class="keyword">while</span> q != t:</span><br><span class="line">                q = q.<span class="built_in">next</span></span><br><span class="line">                t = t.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> t</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h1 id="LRUCache-double-linked-list-O-1"><a href="#LRUCache-double-linked-list-O-1" class="headerlink" title="LRUCache (double linked list) O(1)"></a>LRUCache (double linked list) O(1)</h1><img src="45.png" style="width:800px;"/>

<p>We use double linked list here, and we make two basic operations, called remove and add. The remove is, remove a node by its id from the list, and add is add a node to the end of the tail.<br>-	For the get operation, we firstly remove the node and then add.<br>-	For the put operation, we add it into the list and remove a node from the head.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k, x, <span class="built_in">next</span>=<span class="literal">None</span>, pre=<span class="literal">None</span></span>):</span><br><span class="line">        self.key = k</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        self.pre = pre</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, capacity</span>):</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.<span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line">        self.head = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.tail = Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.pre = self.head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            node = self.<span class="built_in">dict</span>[key]</span><br><span class="line">            self._remove(node)</span><br><span class="line">            self._add(node) </span><br><span class="line">            <span class="keyword">return</span> node.val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.<span class="built_in">dict</span>:</span><br><span class="line">            self._remove(self.<span class="built_in">dict</span>[key])</span><br><span class="line">        node = Node(key, value)</span><br><span class="line">        self._add(node)</span><br><span class="line">        self.<span class="built_in">dict</span>[key] = node</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.<span class="built_in">dict</span>) &gt; self.capacity:</span><br><span class="line">            tmp_node = self.head.<span class="built_in">next</span></span><br><span class="line">            self._remove(tmp_node)</span><br><span class="line">            <span class="keyword">del</span> self.<span class="built_in">dict</span>[tmp_node.key]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_remove</span>(<span class="params">self, node</span>):</span><br><span class="line">        p = node.pre</span><br><span class="line">        n = node.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = n</span><br><span class="line">        n.pre = p</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_add</span>(<span class="params">self, node</span>):</span><br><span class="line">        p = self.tail.pre</span><br><span class="line">        p.<span class="built_in">next</span> = node</span><br><span class="line">        node.pre = p</span><br><span class="line">        node.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.tail.pre = node</span><br></pre></td></tr></table></figure>

<h1 id="SortList-merge-sort-or-quick-sort-O-nlogn"><a href="#SortList-merge-sort-or-quick-sort-O-nlogn" class="headerlink" title="SortList (merge sort or quick sort) O(nlogn)"></a>SortList (merge sort or quick sort) O(nlogn)</h1><img src="46.png" style="width:800px;"/>

<p>Using three list to store nodes, using head as the partition node, left_head stores the nodes whose value is less than partition node, right_head stores the nodes whose value is larger than partition node. partition_head stores the nodes whose value is equal with its value.</p>
<p>Then we recursive to call the sort function to sort left_head, right_head, at the final, we link these three lists together.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">head</span>):</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        partition_node = head</span><br><span class="line">        middle_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        middle_cur = middle_head</span><br><span class="line">        left_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        left_cur = left_head</span><br><span class="line">        right_head = ListNode(<span class="literal">None</span>)</span><br><span class="line">        right_cur = right_head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; partition_node.val:</span><br><span class="line">                left_cur.<span class="built_in">next</span> = ListNode(head.val)</span><br><span class="line">                left_cur = left_cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">elif</span> head.val &gt; partition_node.val:</span><br><span class="line">                right_cur.<span class="built_in">next</span> = ListNode(head.val)</span><br><span class="line">                right_cur = right_cur.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                middle_cur.<span class="built_in">next</span> = ListNode(head.val)</span><br><span class="line">                middle_cur = middle_cur.<span class="built_in">next</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        left_head, left_tail = recursive(left_head.<span class="built_in">next</span>)</span><br><span class="line">        right_head, right_tail = recursive(right_head.<span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left_head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            left_tail.<span class="built_in">next</span> = middle_head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left_head = middle_head</span><br><span class="line">        <span class="keyword">if</span> right_head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            middle_cur.<span class="built_in">next</span> = right_head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right_tail = middle_cur</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left_head, right_tail</span><br><span class="line"></span><br><span class="line">    head, _ = recursive(head)</span><br><span class="line">    <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h1 id="mark-maxProduct-greedy-O-n"><a href="#mark-maxProduct-greedy-O-n" class="headerlink" title="(mark) maxProduct (greedy) O(n)"></a>(mark) maxProduct (greedy) O(n)</h1><img src="47.png" style="width:800px;"/>

<p>we record the min and max value together, each time, we compare and update these two values.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    maximum = b = s = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        b, s = <span class="built_in">max</span>(num, b * num, s * num), <span class="built_in">min</span>(num, b * num, s * num)</span><br><span class="line">        maximum = <span class="built_in">max</span>(maximum, b)</span><br><span class="line">    <span class="keyword">return</span> maximum</span><br></pre></td></tr></table></figure>

<h1 id="MinStack-trick-O-n"><a href="#MinStack-trick-O-n" class="headerlink" title="MinStack (trick) O(n)"></a>MinStack (trick) O(n)</h1><img src="48.png" style="width:800px;"/>

<p>We use another stack to record the current min, each time we push a value, we compare it with the min[-1], if this valuer is larger, we duplicate min[-1], else we push value into the stack. And each time we need to pop a value, we also pop the min[-1].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">min</span> = []</span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.<span class="built_in">min</span>:</span><br><span class="line">            self.<span class="built_in">min</span>.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.<span class="built_in">min</span>.append(<span class="built_in">min</span>(self.<span class="built_in">min</span>[-<span class="number">1</span>], x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.<span class="built_in">min</span>.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">min</span>[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="GetIntersectionNode-trick-O-m-n"><a href="#GetIntersectionNode-trick-O-m-n" class="headerlink" title="GetIntersectionNode (trick) O(m+n)"></a>GetIntersectionNode (trick) O(m+n)</h1><img src="49.png" style="width:800px;"/>

<p>For two list p and q, we append the p-&gt;tail-&gt;q, and q-&gt;tail-&gt;p, so once we get <code>_p==_q</code>, we found the intersection.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">headA, headB</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    nodeA = headA</span><br><span class="line">    nodeB = headB</span><br><span class="line">    <span class="keyword">while</span> nodeA <span class="keyword">is</span> <span class="keyword">not</span> nodeB:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nodeA <span class="keyword">and</span> nodeB:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> nodeA.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            nodeA = headB</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeA = nodeA.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> nodeB.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            nodeB = headA</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nodeB = nodeB.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> nodeA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">headA, headB</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">len</span>(<span class="params">head</span>):</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    lenA, lenB = <span class="built_in">len</span>(headA), <span class="built_in">len</span>(headB)</span><br><span class="line">    diff = <span class="built_in">abs</span>(lenA - lenB)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(diff):</span><br><span class="line">            headA = headA.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(diff):</span><br><span class="line">            headB = headB.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> headA != headB:</span><br><span class="line">        headA = headA.<span class="built_in">next</span></span><br><span class="line">        headB = headB.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> headA</span><br></pre></td></tr></table></figure>

<h1 id="MajorityElement-trick-O-n"><a href="#MajorityElement-trick-O-n" class="headerlink" title="MajorityElement (trick) O(n)"></a>MajorityElement (trick) O(n)</h1><img src="50.png" style="width:800px;"/>

<p> Make two variable, value and count, once count&#x3D;0, we make value&#x3D;nums[i], and count+&#x3D;1, if nums[i]&#x3D;&#x3D;value, make count+&#x3D;1, else count-&#x3D;1.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    cur_value = nums[<span class="number">0</span>]</span><br><span class="line">    cur_num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> num != cur_value:</span><br><span class="line">            cur_num -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur_num == -<span class="number">1</span>:</span><br><span class="line">                cur_value = num</span><br><span class="line">                cur_num = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cur_value</span><br></pre></td></tr></table></figure>

<h1 id="Rob-dp-O-n"><a href="#Rob-dp-O-n" class="headerlink" title="Rob (dp) O(n)"></a>Rob (dp) O(n)</h1><img src="51.png" style="width:800px;"/>

<p>Solution 1: using two arary, max_rob, max_not_rob. max_rob[i] means the max value when we rob nums[i], and max_not_rob means the max value when we don’t rob nums[i].<br>-	max_rob[i] &#x3D; max_not_rob[i-1] + nums[i]<br>-	max_not_rob[i] &#x3D; max(max_not_rob[i-1], max_rob[i-1])</p>
<p>Solution 2:<br>-	f(0) &#x3D; nums[0]<br>-	f(1) &#x3D; max(num[0], num[1])<br>-	f(k) &#x3D; max(f(k-2) + nums[k], f(k-1))</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]  <span class="comment"># (rob, not_rob) * n</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>] + nums[i]</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    last, now = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        last, now = now, <span class="built_in">max</span>(last + i, now)</span><br><span class="line">    <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure>

<h1 id="numIslands-BFS-DFS-O-mn"><a href="#numIslands-BFS-DFS-O-mn" class="headerlink" title="numIslands (BFS DFS) O(mn)"></a>numIslands (BFS DFS) O(mn)</h1><img src="52.png" style="width:800px;"/>

<p>For loop all cells, once found a ‘1’, using stack to do BFS, and for each cell visited, change it to ‘0’</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">grid</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(grid) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(grid)</span><br><span class="line">    m = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                grid[i][j] = <span class="string">&quot;0&quot;</span></span><br><span class="line">                ret += <span class="number">1</span></span><br><span class="line">                queue = [(i, j)]</span><br><span class="line">                <span class="keyword">while</span> queue:</span><br><span class="line">                    _i, _j = queue.pop(<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">if</span> _i &gt; <span class="number">0</span> <span class="keyword">and</span> grid[_i - <span class="number">1</span>][_j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        grid[_i - <span class="number">1</span>][_j] = <span class="string">&quot;0&quot;</span></span><br><span class="line">                        queue.append((_i - <span class="number">1</span>, _j))</span><br><span class="line">                    <span class="keyword">if</span> _j &gt; <span class="number">0</span> <span class="keyword">and</span> grid[_i][_j - <span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        grid[_i][_j - <span class="number">1</span>] = <span class="string">&quot;0&quot;</span></span><br><span class="line">                        queue.append((_i, _j - <span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">if</span> _i &lt; n - <span class="number">1</span> <span class="keyword">and</span> grid[_i + <span class="number">1</span>][_j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        grid[_i + <span class="number">1</span>][_j] = <span class="string">&quot;0&quot;</span></span><br><span class="line">                        queue.append((_i + <span class="number">1</span>, _j))</span><br><span class="line">                    <span class="keyword">if</span> _j &lt; m - <span class="number">1</span> <span class="keyword">and</span> grid[_i][_j + <span class="number">1</span>] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                        grid[_i][_j + <span class="number">1</span>] = <span class="string">&quot;0&quot;</span></span><br><span class="line">                        queue.append((_i, _j + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="mark-canFinish-dfs-O-n-3"><a href="#mark-canFinish-dfs-O-n-3" class="headerlink" title="(mark) canFinish (dfs) O(n^3)"></a>(mark) canFinish (dfs) O(n^3)</h1><img src="53.png" style="width:800px;"/>

<p>We set an array called visited to record which node has been visited. At the first, we set all visited[i]&#x3D;0. When we recursively to search each node, we set its visited[i]&#x3D;-1, once we’ve finished, we set it back to visited[i]&#x3D;1. So, when the recursive function found a visited[i]&#x3D;-1, return False, and visited[i]&#x3D;1(avoid repeatedly search), return True. </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">numCourses, prerequisites</span>):</span><br><span class="line">    grid = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">    visited = [<span class="number">0</span>] * numCourses</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> prerequisites:</span><br><span class="line">        grid[i].append(j)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recusive</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="keyword">if</span> visited[i] == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> visited[i] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        visited[i] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> grid[i]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> recusive(j):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        visited[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> recusive(i):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Trie-tree-O-n"><a href="#Trie-tree-O-n" class="headerlink" title="Trie (tree) O(n)"></a>Trie (tree) O(n)</h1><img src="54.png" style="width:800px;"/>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.<span class="built_in">next</span> = [<span class="literal">None</span>] * <span class="number">26</span></span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.root = TrieNode(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            idx = <span class="built_in">ord</span>(w) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.<span class="built_in">next</span>[idx]:</span><br><span class="line">                node.<span class="built_in">next</span>[idx] = TrieNode(<span class="literal">False</span>)</span><br><span class="line">            node = node.<span class="built_in">next</span>[idx]</span><br><span class="line">        node.val = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            idx = <span class="built_in">ord</span>(w) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.<span class="built_in">next</span>[idx]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node.<span class="built_in">next</span>[idx]</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        :type prefix: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            idx = <span class="built_in">ord</span>(w) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.<span class="built_in">next</span>[idx]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node.<span class="built_in">next</span>[idx]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="mark-findKthLargest-heap-quickselect-O-nlogn"><a href="#mark-findKthLargest-heap-quickselect-O-nlogn" class="headerlink" title="(mark) findKthLargest (heap, quickselect) O(nlogn)"></a>(mark) findKthLargest (heap, quickselect) O(nlogn)</h1><img src="55.png" style="width:800px;"/>

<p>The heap is easy. The quickselect is similar with quicksort, each time we select a pivot, and partition the array to two parts, if the len(left_part)&#x3D;k-1, we return this pivot, else if larger, we continue to find k-th in the left_part, else, we found the k-len(left_part)-1-th at the right part.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(klogk+2(n-k)logk)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    k_heap = nums[<span class="number">0</span>:k]</span><br><span class="line">    heapq.heapify(k_heap)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">        heapq.heappush(k_heap, nums[i])</span><br><span class="line">        heapq.heappop(k_heap)</span><br><span class="line">    <span class="keyword">return</span> heapq.heappop(k_heap)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, k</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">nums, k</span>):</span><br><span class="line">        pivot = nums.pop(<span class="built_in">len</span>(nums) // <span class="number">2</span>)</span><br><span class="line">        right = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num &gt; pivot]</span><br><span class="line">        lr = <span class="built_in">len</span>(right)</span><br><span class="line">        <span class="keyword">if</span> k == lr + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> pivot</span><br><span class="line">        <span class="keyword">elif</span> k &lt; lr + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> recursive(right, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = [num <span class="keyword">for</span> num <span class="keyword">in</span> nums <span class="keyword">if</span> num &lt;= pivot]</span><br><span class="line">            <span class="keyword">return</span> recursive(left, k - lr - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(nums, k)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="maximalSquare-dp-O-n-2"><a href="#maximalSquare-dp-O-n-2" class="headerlink" title="maximalSquare (dp) O(n^2)"></a>maximalSquare (dp) O(n^2)</h1><img src="56.png" style="width:800px;"/>

<ul>
<li>   dp[i][j] &#x3D; min((dp[i-1][j-1]), (dp[i][j-1]), (dp[i-1][j])) + 1, if matrix[i][j]) &#x3D;&#x3D; 1</li>
<li>   max_v &#x3D; max(max_v, dp[i][j])</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">matrix</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    dp = [[<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> row] <span class="keyword">for</span> row <span class="keyword">in</span> matrix]</span><br><span class="line">    max_v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                max_v = <span class="built_in">max</span>(max_v, dp[i][j])</span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">                max_v = <span class="built_in">max</span>(max_v, dp[i][j])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][j] == <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> max_v**<span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="invertTree-recursive-O-n"><a href="#invertTree-recursive-O-n" class="headerlink" title="invertTree (recursive) O(n)"></a>invertTree (recursive) O(n)</h1><img src="57.png" style="width:800px;"/>

<p>root.left, root.right &#x3D; recursive(root.right), recursive(root.left)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left, root.right = recursive(root.right), recursive(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(root)</span><br></pre></td></tr></table></figure>

<h1 id="isPalindrome-trick-O-n"><a href="#isPalindrome-trick-O-n" class="headerlink" title="isPalindrome (trick) O(n)"></a>isPalindrome (trick) O(n)</h1><img src="58.png" style="width:800px;"/>

<p>We use pointers, faster and slower, faster&#x3D;faster.next.next, slow&#x3D;slow.next. once we found he mid of the array, we reverse the half end of the list.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">head</span>):</span><br><span class="line">    rev = ListNode(<span class="literal">None</span>)</span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        _slow = slow</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        _slow.<span class="built_in">next</span> = rev.<span class="built_in">next</span></span><br><span class="line">        rev.<span class="built_in">next</span> = _slow</span><br><span class="line">    <span class="keyword">if</span> fast:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    rev = rev.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> rev <span class="keyword">and</span> slow:</span><br><span class="line">        <span class="keyword">if</span> rev.val != slow.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rev = rev.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="lowestCommonAncestor-recursive-O-n"><a href="#lowestCommonAncestor-recursive-O-n" class="headerlink" title="lowestCommonAncestor (recursive) O(n)"></a>lowestCommonAncestor (recursive) O(n)</h1><img src="59.png" style="width:800px;"/>

<p>use postorder recursive, count &#x3D; recusive(root.left, p, q) + recusive(root.right, p, q), if root.val &#x3D;&#x3D;p or &#x3D;&#x3D;q: cur_count &#x3D;&#x3D;1 else 0. If count+cur_count &#x3D;&#x3D;2, return the result.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root, p, q</span>):</span><br><span class="line">    low_desc = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> low_desc</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ret = recursive(root.left)</span><br><span class="line">        <span class="keyword">if</span> ret &lt; <span class="number">2</span>:</span><br><span class="line">            ret += recursive(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.val <span class="keyword">in</span> (q.val, p.val):</span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> ret == <span class="number">2</span> <span class="keyword">and</span> <span class="keyword">not</span> low_desc:</span><br><span class="line">            low_desc = root</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    recursive(root)</span><br><span class="line">    <span class="keyword">return</span> low_desc</span><br></pre></td></tr></table></figure>

<h1 id="productExceptSelf-two-pointers-reverse-list-O-n"><a href="#productExceptSelf-two-pointers-reverse-list-O-n" class="headerlink" title="productExceptSelf (two pointers, reverse list) O(n)"></a>productExceptSelf (two pointers, reverse list) O(n)</h1><img src="60.png" style="width:800px;"/>

<p>We use two arrays, the first to record the product of left values, and second to record the product of right values. Then result[i] &#x3D; left[i] * right[i]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    res = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    p = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        res[i] = p</span><br><span class="line">        p *= nums[i]</span><br><span class="line"></span><br><span class="line">    right = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        res[i] *= right</span><br><span class="line">        right *= nums[i]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="maxSlidingWindow-trick-O-n"><a href="#maxSlidingWindow-trick-O-n" class="headerlink" title="maxSlidingWindow (trick) O(n)"></a>maxSlidingWindow (trick) O(n)</h1><img src="61.png" style="width:800px;"/>

<p>Actually, we don’t need to re-calculate the max value each time. We use an array called result to record the max values. Each time:<br>-	If the new value is larger than current max value, we add it into the result array.<br>-	Else if the value will be deleted from the window is less than current max value, we add the current max value into the result again.<br>-	Else we re-calculate the max value within the window.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, k</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line">    ret = [<span class="built_in">max</span>(nums[:k])]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums) - k + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i + k - <span class="number">1</span>] &gt;= ret[-<span class="number">1</span>]:</span><br><span class="line">            ret.append(nums[i + k - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> nums[i - <span class="number">1</span>] &lt; ret[-<span class="number">1</span>]:</span><br><span class="line">            ret.append(ret[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret.append(<span class="built_in">max</span>(nums[i:i + k]))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="mark-searchMatrix-trick-O-m-n"><a href="#mark-searchMatrix-trick-O-m-n" class="headerlink" title="(mark) searchMatrix (trick) O(m+n)"></a>(mark) searchMatrix (trick) O(m+n)</h1><img src="62.png" style="width:800px;"/>

<p>At the first row, we search from the end, exclude the values which are larger than target, and we record the index, then at the second row, we search from the index to exclude again. We return True once we found the target, else we return False.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">matrix, target</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    j = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix)):</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> matrix[i][j] &gt; target:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> matrix[i][j] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h1 id="numSquares-dp-O-n-1-5"><a href="#numSquares-dp-O-n-1-5" class="headerlink" title="numSquares (dp) O(n^1.5)"></a>numSquares (dp) O(n^1.5)</h1><img src="63.png" style="width:800px;"/>

<p>first we set search range(nums) is [1, floor(n^0.5)], then for dp[i]&#x3D;min(dp[i-range[j]^2]+1) over all j.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math, sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">n</span>):</span><br><span class="line">    dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    squares = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(math.sqrt(n)) + <span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        min_v = sys.maxsize</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> squares:</span><br><span class="line">            <span class="keyword">if</span> i - j &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            min_v = <span class="built_in">min</span>(min_v, dp[i - j])</span><br><span class="line">        dp[i] = min_v + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="moveZeroes-trick-O-n"><a href="#moveZeroes-trick-O-n" class="headerlink" title="moveZeroes (trick) O(n)"></a>moveZeroes (trick) O(n)</h1><img src="64.png" style="width:800px;"/>

<p>Each time we encounter a non-zero value, we need to swap it with the first zero. So, we set an index to record the first zero’s position, if nums[i]!&#x3D;0, we add one to this index, and swap nums[index] with nums[i], else we do nothing. </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    j = i</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> nums[j] == <span class="number">0</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j &gt;= n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> nums[j] != <span class="number">0</span>:</span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="findDuplicate-trick-O-n"><a href="#findDuplicate-trick-O-n" class="headerlink" title="findDuplicate (trick) O(n)"></a>findDuplicate (trick) O(n)</h1><img src="65.png" style="width:800px;"/>

<p>We take this question as detectCycle, the number i will point to the nums[i], because there are multiply number are same, it means this number will point to a same number. And this number must be the start of the cycle.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    slow = nums[<span class="number">0</span>]</span><br><span class="line">    fast = nums[nums[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">while</span> fast != slow:</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">    slow = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[fast]</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="MedianFinder-trick-O-nlogn"><a href="#MedianFinder-trick-O-nlogn" class="headerlink" title="MedianFinder (trick) O(nlogn)"></a>MedianFinder (trick) O(nlogn)</h1><img src="66.png" style="width:800px;"/>

<p>Solution1: we maintain a sorted list, each time we using binary search to find the right position to insert the upcoming value.</p>
<p>Solution2: we use two heaps, large heap and small heap. Each time, if the length of the two heaps is equal, then we firstly add the value into the large heap, then we pop the smallest value from the large heap, and then add it into the small heap. If length not equal, we add the value into the small heap and pop the largest value then add it into the large heap. Finally, if the length is equal, we return the average of the values from top of small and large heaps. If equal, we return the value from the top of large heap.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.left_heap = []</span><br><span class="line">        self.right_heap = []</span><br><span class="line">        heapq.heapify(self.left_heap)  <span class="comment"># big heap</span></span><br><span class="line">        heapq.heapify(self.right_heap)  <span class="comment"># small heap</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addNum</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.left_heap) == <span class="built_in">len</span>(self.right_heap):</span><br><span class="line">            heapq.heappush(self.left_heap,</span><br><span class="line">                           -heapq.heappushpop(self.right_heap, num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.right_heap,</span><br><span class="line">                           -heapq.heappushpop(self.left_heap, -num))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedian</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.left_heap) == <span class="built_in">len</span>(self.right_heap):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(-self.left_heap[<span class="number">0</span>] + self.right_heap[<span class="number">0</span>]) / <span class="number">2.</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(-self.left_heap[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h1 id="Serialize-bfs-O-n"><a href="#Serialize-bfs-O-n" class="headerlink" title="Serialize (bfs) O(n)"></a>Serialize (bfs) O(n)</h1><img src="67.png" style="width:800px;"/>

<p>The children of each node[i] is node[2i] and node[2i+1]</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self, root</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :type root: TreeNode</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    out = []</span><br><span class="line">    queue = collections.deque([root])</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        out.append(<span class="built_in">str</span>(node.val) <span class="keyword">if</span> node <span class="keyword">else</span> <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(out)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deserialize</span>(<span class="params">self, data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :type data: str</span></span><br><span class="line"><span class="string">    :rtype: TreeNode</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    out = data.split()</span><br><span class="line">    bfs = [TreeNode(<span class="built_in">int</span>(i)) <span class="keyword">if</span> i != <span class="string">&#x27;#&#x27;</span> <span class="keyword">else</span> <span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> out]</span><br><span class="line">    slow_idx = <span class="number">0</span>  <span class="comment"># the id in array nodex</span></span><br><span class="line">    fast_idx = <span class="number">1</span>  <span class="comment"># the id in array bfs</span></span><br><span class="line">    root = bfs[<span class="number">0</span>]</span><br><span class="line">    nodes = [root]</span><br><span class="line">    <span class="keyword">while</span> slow_idx &lt; <span class="built_in">len</span>(nodes):</span><br><span class="line">        node = nodes[slow_idx]</span><br><span class="line">        slow_idx += <span class="number">1</span>  <span class="comment"># each time we handle one node in nodes</span></span><br><span class="line">        node.left = bfs[fast_idx]</span><br><span class="line">        node.right = bfs[fast_idx + <span class="number">1</span>]</span><br><span class="line">        fast_idx += <span class="number">2</span>  <span class="comment"># each time we only handle two nodes in bfs</span></span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            nodes.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            nodes.append(node.right)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h1 id="lengthOfLIS-dp"><a href="#lengthOfLIS-dp" class="headerlink" title="lengthOfLIS(dp)"></a>lengthOfLIS(dp)</h1><img src="68.png" style="width:800px;"/>

<h2 id="lengthOfLIS-dp-O-n-2"><a href="#lengthOfLIS-dp-O-n-2" class="headerlink" title="lengthOfLIS(dp) O(n^2)"></a>lengthOfLIS(dp) O(n^2)</h2><p>The dp[i] stores the longest length till current position, each time we compare the current value with all previous values, if the current value is larger than a previous value, we record its dp value:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        max_t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                max_t = <span class="built_in">max</span>(max_t, dp[j]) <span class="comment"># # longest length till now plus current </span></span><br><span class="line">        dp[i] = max_t + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>

<h2 id="mark-lengthOfLIS-dp-O-nlogn"><a href="#mark-lengthOfLIS-dp-O-nlogn" class="headerlink" title="(mark) lengthOfLIS(dp) O(nlogn)"></a>(mark) lengthOfLIS(dp) O(nlogn)</h2><p>The dp[i] stores the increasing subsequence formed by including the currently encountered element.</p>
<p>For example, for input: [0, 8, 4, 12, 2],</p>
<p>We iterate each value in the input, each time we find the position in dp which value is the first one larger than current value in the input. For example, for 0, we have dp: [0]; for 8, we have dp: [0, 8]; for 4, we have dp: [0, 4]; then for 12, all values is smaller than 12, so we have append it at the end of dp: [0, 4, 12]; for 2, we have dp: [0, 2, 12]. The final dp is not the longest increasing subsequence, but length of dp array results in length of Longest Increasing Subsequence.</p>
<p>The reason why we update the value from [0, 4, 12] to [0, 2, 12], is 1, the update doesn’t break the feature of length of LIS,  2, once we encounter a value which is larger than 2, we update 12 then, so this makes sure we can find a longer LIS then. </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># o(n^2)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n * logn)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    dp = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">    size = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        i, j = <span class="number">0</span>, size</span><br><span class="line">        <span class="keyword">while</span> i != j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> dp[m] &lt; n:</span><br><span class="line">                i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = m</span><br><span class="line">        dp[i] = n</span><br><span class="line">        size = <span class="built_in">max</span>(size, i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure>

<h1 id="removeInvalidParentheses-recursive-O-n-2"><a href="#removeInvalidParentheses-recursive-O-n-2" class="headerlink" title="removeInvalidParentheses(recursive) O(n^2)"></a>removeInvalidParentheses(recursive) O(n^2)</h1><img src="69.png" style="width:800px;"/>

<p>We use a counter to check a string of parentheses is valid. The counter will increase when it is ‘(‘ and decrease when it is ‘)’. Whenever the counter is negative, we have more ‘)’ than ‘(‘ in the prefix.</p>
<p>To make the prefix valid, we need to remove a ‘)’. The problem is: which one? The answer is any one in the prefix. However, if we remove any one, we will generate duplicate results, for example: s &#x3D; ()), we can remove s[1] or s[2] but the result is the same (). Thus, we restrict ourselves to remove the first ‘)’ in a series of consecutive ‘)’s.</p>
<p>After the removal, the prefix is then valid. We then call the function recursively to solve the rest of the string. However, we need to keep another information: the last removal position. If we do not have this position, we will generate duplicate by removing two ‘)’ in two steps only with a different order.</p>
<p>For this, we keep tracking the last removal position and only remove ‘)’ after that. So, we need two flags, the first i means till i the string is valid, and j means we should start removing ‘)’ from j. And for ‘)’ between i and j, we call recursive function to remove every ‘)’.</p>
<p>Now one may ask. What about ‘(‘? What if s &#x3D; ‘(()(()’ in which we need remove ‘(‘?</p>
<p>The answer is: do the same from right to left.</p>
<p>However, a cleverer idea is: reverse the string and reuse the code!</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeInvalidParentheses</span>(<span class="params">self, s</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :rtype: List[str]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeHelper</span>(<span class="params">s, output, iStart, jStart, openParen, closedParen</span>):</span><br><span class="line">        numOpenParen, numClosedParen = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iStart, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == openParen:</span><br><span class="line">                numOpenParen += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == closedParen:</span><br><span class="line">                numClosedParen += <span class="number">1</span></span><br><span class="line">            <span class="comment"># We have only ONE extra closed paren we need to remove</span></span><br><span class="line">            <span class="keyword">if</span> numClosedParen &gt; numOpenParen:</span><br><span class="line">                <span class="built_in">print</span>(s)</span><br><span class="line">                <span class="keyword">if</span> openParen == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;positive&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> openParen == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;negative&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;i=&quot;</span>, i, numOpenParen, numClosedParen)</span><br><span class="line">                <span class="comment"># Try removing this ONE closed paren at each position, skipping duplicates</span></span><br><span class="line">                <span class="built_in">print</span>(jStart, i)</span><br><span class="line">                <span class="comment"># jStart: always to search the first closedParen which can be removed</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(jStart, i+<span class="number">1</span>):  <span class="comment"># &lt;=</span></span><br><span class="line">                    <span class="comment"># can be the first char,</span></span><br><span class="line">                    <span class="comment"># or the char which previous char isn&#x27;t closedParen, removing each one of the consequtive closedParen actually is the same</span></span><br><span class="line">                    <span class="keyword">if</span> s[j] == closedParen <span class="keyword">and</span> (j == jStart <span class="keyword">or</span> s[j-<span class="number">1</span>] != closedParen): <span class="comment"># since when j == jStart, there isn&#x27;t j-1</span></span><br><span class="line">                        <span class="comment"># Recursion: iStart = i since we now have valid # closed parenthesis thru i. jStart = j prevents duplicates</span></span><br><span class="line">                        <span class="comment"># at the next recursion, we only need to search the iStart from the current i, and search the jStart from the current j</span></span><br><span class="line">                        <span class="comment"># since we found the first invalid closedParen at the i, and we have removed a closedParen at j</span></span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&quot;remove, j=&quot;</span>, j, s[j])</span><br><span class="line">                        removeHelper(s[:j]+s[j+<span class="number">1</span>:], output,</span><br><span class="line">                                     i, j, openParen, closedParen)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">reversed</span> = s[::-<span class="number">1</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">reversed</span>, <span class="string">&quot;now out of the loop&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> openParen == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            removeHelper(<span class="built_in">reversed</span>, output, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output.append(<span class="built_in">reversed</span>)</span><br><span class="line"></span><br><span class="line">    output = []</span><br><span class="line">    removeHelper(s, output, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<h1 id="maxProfit-dp-O-3n"><a href="#maxProfit-dp-O-3n" class="headerlink" title="maxProfit(dp) O(3n)"></a>maxProfit(dp) O(3n)</h1><img src="70.png" style="width:800px;"/>

<p>We use stack [n][3], stack[i][0] records colldown action, stack[i][1] records buy action, stack[i][0] records sell action.<br>-	For cooldown, we keep the largest profit from the previous day: stack[i][0] &#x3D; max(stack[i-1]).<br>-	For buy, we only consider the previous cooldown action, stack[i][1] &#x3D; stack[i-1][0] - prices[i]. The [buy, cooldown, buy] action will not occur, since the previous cooldown is got from the largest actions(stack[i][0] &#x3D; max(stack[i-1])).<br>-	For sell, stack[i][2] &#x3D; bought + prices[i]. And we record a bought value each time, bought &#x3D; max(bought, stack[i][1]), so each time we keep the max bought which means the samllest cost bought.</p>
<ul>
<li>we record the bought to avoid the [sell, rest, sell], each time we keep the max bought which means the samllest cost bought</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">prices</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(prices)</span><br><span class="line">    buy, sell, cooldown = [<span class="number">0</span>] * n, [<span class="number">0</span>] * n, [<span class="number">0</span>] * n</span><br><span class="line">    bought = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        buy[i] = cooldown[i - <span class="number">1</span>] - prices[i]</span><br><span class="line">        sell[i] = bought + prices[i]</span><br><span class="line">        cooldown[i] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>], sell[i - <span class="number">1</span>], cooldown[i - <span class="number">1</span>])</span><br><span class="line">        bought = <span class="built_in">max</span>(bought, buy[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(buy[-<span class="number">1</span>], sell[-<span class="number">1</span>], cooldown[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h1 id="maxCoins-dp-O-n-3"><a href="#maxCoins-dp-O-n-3" class="headerlink" title="maxCoins(dp) O(n^3)"></a>maxCoins(dp) O(n^3)</h1><img src="71.png" style="width:800px;"/>

<p>First of all, dp[i][j] means, the maximum coins we get after we burst all the balloons between i and j in the original array. So dp[i][j] means we already burst all balloons between i and j. For the transition function:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for k in range(i+1, j):</span><br><span class="line">    coins = max(coins, nums[i]*nums[k]*nums[j] + recursion(i, k) + recursion(k, j))</span><br></pre></td></tr></table></figure>

<p>This transition function basically says in order to get the maximum value we can get for bursting all the balloons between [ i , j] , we just loop through each balloon between these two indexes and make them to be the last balloon to be burst, which means we already burst all balloons from left to k-1, and from k+1 to right.<br>72<br>Notes: we append 1 to the start and end of input, each time we handle the solution from i+1 to j. we actually skep the first and last items. This trick assures the equation is correct: nums[i]*nums[k]*nums[j].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    nums = [<span class="number">1</span>] + nums + [<span class="number">1</span>]</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">i, j</span>):</span><br><span class="line">        <span class="keyword">if</span> dp[i][j] <span class="keyword">or</span> j == i + <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line">        coins = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, j):</span><br><span class="line">            <span class="comment"># we firstly burst (i,k) and (k,j), only leave (i,k,j) three ballons</span></span><br><span class="line">            coins = <span class="built_in">max</span>(</span><br><span class="line">                coins,</span><br><span class="line">                nums[i] * nums[k] * nums[j] + recursive(i, k) + recursive(k, j))</span><br><span class="line">        dp[i][j] = coins</span><br><span class="line">        <span class="keyword">return</span> coins</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="coinChange-dp-O-nm"><a href="#coinChange-dp-O-nm" class="headerlink" title="coinChange(dp) O(nm)"></a>coinChange(dp) O(nm)</h1><img src="72.png" style="width:800px;"/>

<p>dp[i] &#x3D; min(dp[i-coin] + 1) for coin in coins.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">coins, amount</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(coins) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    coins = <span class="built_in">sorted</span>(<span class="built_in">set</span>(coins), reverse=<span class="literal">True</span>)</span><br><span class="line">    dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i == c:</span><br><span class="line">                dp[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> i &gt; c <span class="keyword">and</span> dp[i - c] &gt; <span class="number">0</span>:</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - c] + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> dp[-<span class="number">1</span>] &gt; amount <span class="keyword">else</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Rob-dp-in-a-tree-O-n"><a href="#Rob-dp-in-a-tree-O-n" class="headerlink" title="Rob(dp in a tree), O(n)"></a>Rob(dp in a tree), O(n)</h1><img src="73.png" style="width:800px;"/>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        l_rob, l_not_rob = recursive(root.left)</span><br><span class="line">        r_rob, r_not_rob = recursive(root.right)</span><br><span class="line">        rob = l_not_rob + r_not_rob + root.val</span><br><span class="line">        not_rob = <span class="built_in">max</span>(l_rob, l_not_rob) + <span class="built_in">max</span>(r_rob, r_not_rob)</span><br><span class="line">        <span class="keyword">return</span> rob, not_rob</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(recursive(root))</span><br></pre></td></tr></table></figure>

<h1 id="countBits-dp-O-n"><a href="#countBits-dp-O-n" class="headerlink" title="countBits(dp) O(n)"></a>countBits(dp) O(n)</h1><img src="74.png" style="width:800px;"/>

<p><code>f[i]=f[i // 2] + i % 2</code></p>
<p>just like shift one bit to left and add the remainder.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">num</span>):</span><br><span class="line">    dp = [<span class="number">0</span>] * (num + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        dp[i] = dp[i // <span class="number">2</span>] + i % <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure>

<h1 id="topKFrequent-heap-O-nlogn"><a href="#topKFrequent-heap-O-nlogn" class="headerlink" title="topKFrequent(heap) O(nlogn)"></a>topKFrequent(heap) O(nlogn)</h1><img src="75.png" style="width:800px;"/>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, k</span>):</span><br><span class="line">    hash_map = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        hash_map[num] += <span class="number">1</span></span><br><span class="line">    ret = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key, val <span class="keyword">in</span> hash_map.items():</span><br><span class="line">        <span class="keyword">if</span> i &lt; k:</span><br><span class="line">            heapq.heappush(ret, (val, key))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappushpop(ret, (val, key))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [v <span class="keyword">for</span> k, v <span class="keyword">in</span> ret]</span><br></pre></td></tr></table></figure>

<h1 id="decodeString-stack-O-n"><a href="#decodeString-stack-O-n" class="headerlink" title="decodeString(stack) O(n)"></a>decodeString(stack) O(n)</h1><img src="76.png" style="width:800px;"/>

<p>We use a stack to record chars. Each time we have a ‘]’, we pop and record the chars until the ‘[’, then we continue to find all digital chars, and get handle then to get a 10-based value to repeat the chars we recorded between ‘[’ and ‘]’.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s</span>):</span><br><span class="line">    stack = [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    num = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            num += c</span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">            stack.extend([num, <span class="string">&quot;&quot;</span>])</span><br><span class="line">            num = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">            chars = stack.pop()</span><br><span class="line">            n_chars = stack.pop()</span><br><span class="line">            stack[-<span class="number">1</span>] += chars * <span class="built_in">int</span>(n_chars)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack[-<span class="number">1</span>] += c</span><br><span class="line">    <span class="keyword">return</span> stack.pop()</span><br></pre></td></tr></table></figure>

<h1 id="reconstructQueue-trick-O-nlog"><a href="#reconstructQueue-trick-O-nlog" class="headerlink" title="reconstructQueue(trick) O(nlog)"></a>reconstructQueue(trick) O(nlog)</h1><img src="77.png" style="width:800px;"/>

<p>First we order the list by, people &#x3D; sorted(people, key&#x3D;lambda x: (-x[0], x[1])), the descending order of the first element and ascending value by the second element. </p>
<p>Then we inset the tuple by the index of second element: result.insert(p[1], p).</p>
<p>The reason behind this is, the tuple’s order only be affected by the tuple which is larger than it. So we first to handle the larger tuple. Then, for the second element, we insert it by ascending order to keep the result valid. </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">people</span>):</span><br><span class="line">    people = <span class="built_in">sorted</span>(people, key=<span class="keyword">lambda</span> x: (-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> people:</span><br><span class="line">        ret.insert(p[<span class="number">1</span>], p)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="canPartition"><a href="#canPartition" class="headerlink" title="canPartition"></a>canPartition</h1><img src="78.png" style="width:800px;"/>

<h2 id="canPartition-dp-O-n-s-n"><a href="#canPartition-dp-O-n-s-n" class="headerlink" title="canPartition(dp) O(n*s), n&lt;&#x3D;200, s&lt;&#x3D;10000"></a>canPartition(dp) O(n*s), n&lt;&#x3D;200, s&lt;&#x3D;10000</h2><p>We make a matrix with n*s, n is the number of the input, and s is the sum(input)&#x2F;&#x2F;2. For a cell in the matrix, for example, for i-th row and j-th column, it mean with input[:i], can we get sum value of j. so, the process as following:<br>-	We make all dp[i][nums[i]-1] &#x3D; 1 for i in range(m). it means other values are not selected, only the i-th value’s sum.<br>-	And when we iterate fo i from 1 to m and j from 0 to s. dp[i-1][j] &#x3D;&#x3D; dp[i][j] means when current value is not selected, the sum we get.. And dp[i][j] &#x3D; dp[i-1][j-nums[i]] means when current value is selected, the sum we get.</p>
<h2 id="Partition-dp-O-2-n-with-cutting-branch"><a href="#Partition-dp-O-2-n-with-cutting-branch" class="headerlink" title="Partition(dp) O(2^n with cutting branch)"></a>Partition(dp) O(2^n with cutting branch)</h2><p>just reclusively call helper(nums[i+1:], target-num) for i, num in enumerate(nums)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(N * S)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    sum_v = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_v % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">max</span>(nums) &gt; sum_v // <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    scale = sum_v // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    dp = [[<span class="literal">False</span>] * scale <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line"></span><br><span class="line">    nums = <span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>)</span><br><span class="line">    dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        dp[i][nums[i]] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(scale - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> dp[i - <span class="number">1</span>][j]:</span><br><span class="line">                dp[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; nums[i] <span class="keyword">and</span> dp[i - <span class="number">1</span>][j - nums[i]]:</span><br><span class="line">                dp[i][j] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">nums, target</span>):</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num &gt; target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> num == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> recursive(nums[i + <span class="number">1</span>:], target - nums[i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    sum_v = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_v % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    nums = <span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> recursive(nums, sum_v // <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h1 id="pathSum-dp-O-n"><a href="#pathSum-dp-O-n" class="headerlink" title="pathSum(dp) O(n)"></a>pathSum(dp) O(n)</h1><img src="79.png" style="width:800px;"/>

<p>We assume all paths are from root, then there is an old path called oldPathsum, when we continue to go down the tree, we have a new path called currPathSum, once oldPathsum &#x3D; currPathSum – target, we found a path, so we result +&#x3D; cache.get(oldPathsum, 0). </p>
<p>Note, when we enter a node, we make cache[currPathSum] &#x3D; cache.get(currPathSum, 0) + 1, and then we iterate its children, and once we leave this node, we make cache[currPathSum] -&#x3D; 1.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root, target</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">root, cur_sum</span>):</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">nonlocal</span> ret</span><br><span class="line">            cur_sum += root.val</span><br><span class="line">            ret += cache.get(cur_sum - target, <span class="number">0</span>)</span><br><span class="line">            cache[cur_sum] = cache.get(cur_sum, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            recursive(root.left, cur_sum)</span><br><span class="line">            recursive(root.right, cur_sum)</span><br><span class="line">            cache[cur_sum] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    cache = &#123;<span class="number">0</span>: <span class="number">1</span>&#125;</span><br><span class="line">    recursive(root, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="findAnagrams-cache-O-n"><a href="#findAnagrams-cache-O-n" class="headerlink" title="findAnagrams(cache) O(n)"></a>findAnagrams(cache) O(n)</h1><img src="80.png" style="width:800px;"/>

<p>Using a 26 sized cache to stores the current frequency of substring. Each time we slide the window to update the cache and compare it with the cache of target. </p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s, p</span>):</span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    ret = []</span><br><span class="line">    p_counter = collections.Counter(p)</span><br><span class="line">    s_counter = collections.Counter(s[:<span class="built_in">len</span>(p) - <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p) - <span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        s_counter[s[i]] += <span class="number">1</span></span><br><span class="line">        pre_i = i - <span class="built_in">len</span>(p) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s_counter == p_counter:</span><br><span class="line">            ret.append(pre_i)</span><br><span class="line">        s_counter[s[pre_i]] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s_counter[s[pre_i]] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">del</span> s_counter[s[pre_i]]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">s, p</span>):</span><br><span class="line">    l = <span class="built_in">len</span>(p)</span><br><span class="line">    p_frequency = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    ss_frequency = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> p:</span><br><span class="line">        p_frequency[<span class="built_in">ord</span>(c) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s[<span class="number">0</span>:l]:</span><br><span class="line">        ss_frequency[<span class="built_in">ord</span>(c) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> p_frequency == ss_frequency:</span><br><span class="line">        res.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s) - l + <span class="number">1</span>):</span><br><span class="line">        ss_frequency[<span class="built_in">ord</span>(s[i - <span class="number">1</span>]) - <span class="number">97</span>] -= <span class="number">1</span></span><br><span class="line">        ss_frequency[<span class="built_in">ord</span>(s[i + l - <span class="number">1</span>]) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p_frequency == ss_frequency:</span><br><span class="line">            res.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="findDisappearedNumbers-trick-n"><a href="#findDisappearedNumbers-trick-n" class="headerlink" title="findDisappearedNumbers(trick) (n)"></a>findDisappearedNumbers(trick) (n)</h1><img src="81.png" style="width:800px;"/>

<p>We iterate the array, to mark the seen position as negative.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        _num = <span class="built_in">abs</span>(nums[i])</span><br><span class="line">        <span class="keyword">if</span> _num &lt;= n:</span><br><span class="line">            nums[_num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[_num - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            ret.append(i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="findTargetSumWays-dp-O-n-2s-s-sum-nums"><a href="#findTargetSumWays-dp-O-n-2s-s-sum-nums" class="headerlink" title="findTargetSumWays(dp) O(n*2s) s&#x3D;sum(nums)"></a>findTargetSumWays(dp) O(n*2s) s&#x3D;sum(nums)</h1><p>the matrix of dp is dp[0:n][-s:s], for row is 0, we take dp[0][+-nums[0]] &#x3D;1, and then for later rows, dp[i][j] &#x3D; dp[i][j-nums[i]] + dp[i][j+nums[i]].</p>
<img src="82.png" style="width:800px;"/>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, S</span>):</span><br><span class="line">    sum_v = <span class="built_in">sum</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> sum_v &lt; S: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">0</span>] * (<span class="number">2</span> * sum_v + <span class="number">1</span>)</span><br><span class="line">    dp[nums[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">    dp[-nums[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        _dp = [<span class="number">0</span>] * (<span class="number">2</span> * sum_v + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-sum_v, sum_v + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i + n &lt;= sum_v:</span><br><span class="line">                _dp[i] += dp[i + n]</span><br><span class="line">            <span class="keyword">if</span> i - n &gt;= -sum_v:</span><br><span class="line">                _dp[i] += dp[i - n]</span><br><span class="line">        dp = _dp</span><br><span class="line">    <span class="keyword">return</span> dp[S]</span><br></pre></td></tr></table></figure>

<h1 id="diameterOfBinaryTree-tree-dp-n"><a href="#diameterOfBinaryTree-tree-dp-n" class="headerlink" title="diameterOfBinaryTree(tree dp) (n)"></a>diameterOfBinaryTree(tree dp) (n)</h1><img src="83.png" style="width:800px;"/>

<p>From the leave, at each parent, we update the result &#x3D; max(result, a+b+1), a is the longest length from left, b is from right. Then we transfer max(a, b) to this parent as its longest length.</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">root</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recusive</span>(<span class="params">root</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> ret</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        l = recusive(root.left)</span><br><span class="line">        r = recusive(root.right)</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, <span class="built_in">max</span>(l) + <span class="built_in">max</span>(r))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l) + <span class="number">1</span>, <span class="built_in">max</span>(r) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    recusive(root)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="subarraySum-hash-trick-O-n"><a href="#subarraySum-hash-trick-O-n" class="headerlink" title="subarraySum(hash trick) O(n)"></a>subarraySum(hash trick) O(n)</h1><img src="84.png" style="width:800px;"/>

<p>similar with findTargetSumWays</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n^2)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, k</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># (start_pos, len)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                dp[j][i] = nums[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[j][i] = nums[j] + dp[j + <span class="number">1</span>][i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> dp[j][i] == k:</span><br><span class="line">                ret += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums, k</span>):</span><br><span class="line">    cache = &#123;<span class="number">0</span>: <span class="number">1</span>&#125;</span><br><span class="line">    cur_sum = <span class="number">0</span></span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        cur_sum += n</span><br><span class="line">        ret += cache.get(cur_sum - k, <span class="number">0</span>)</span><br><span class="line">        cache[cur_sum] = cache.get(cur_sum, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h1 id="findUnsortedSubarray-trick-O-n"><a href="#findUnsortedSubarray-trick-O-n" class="headerlink" title="findUnsortedSubarray(trick) O(n)"></a>findUnsortedSubarray(trick) O(n)</h1><img src="85.png" style="width:800px;"/>

<p>We firstly iterate from left, each time, we store the current max value, and once we found the current value is smaller than the current max value, we mark it position. Then we iterate from right using min value to do again. Finally the result is max(right-left+1, 0).</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    right = <span class="number">0</span></span><br><span class="line">    cur_max = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; cur_max:</span><br><span class="line">            right = i</span><br><span class="line">        cur_max = <span class="built_in">max</span>(cur_max, nums[i])</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    cur_min = nums[-<span class="number">1</span>]</span><br><span class="line">    left = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; cur_min:</span><br><span class="line">            left = i</span><br><span class="line">        cur_min = <span class="built_in">min</span>(cur_min, nums[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(right - left + <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h1 id="mergeTrees-recursive-O-n"><a href="#mergeTrees-recursive-O-n" class="headerlink" title="mergeTrees(recursive) O(n)"></a>mergeTrees(recursive) O(n)</h1><img src="86.png" style="width:800px;"/>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">t1, t2</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recursive</span>(<span class="params">t1, t2</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1 <span class="keyword">and</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> t1:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t1.left = recursive(t1.left, t2.left)</span><br><span class="line">            t1.right = recursive(t1.right, t2.right)</span><br><span class="line">            t1.val = t1.val + t2.val</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recursive(t1, t2)</span><br></pre></td></tr></table></figure>

<h1 id="leastInterval-trick-O-n"><a href="#leastInterval-trick-O-n" class="headerlink" title="leastInterval(trick) O(n)"></a>leastInterval(trick) O(n)</h1><img src="87.png" style="width:800px;"/>

<img src="87.5.png" style="width:800px;"/>

<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">tasks, n</span>):</span><br><span class="line">    cache = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> tasks:</span><br><span class="line">        cache[<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">    cache.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    max_v = cache[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">    idle_slots = max_v * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(cache)):</span><br><span class="line">        <span class="keyword">if</span> cache[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        idle_slots -= <span class="built_in">min</span>(cache[i], max_v)</span><br><span class="line">    <span class="keyword">return</span> idle_slots + <span class="built_in">len</span>(tasks) <span class="keyword">if</span> idle_slots &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">len</span>(tasks)</span><br></pre></td></tr></table></figure>


<h1 id="countSubstrings"><a href="#countSubstrings" class="headerlink" title="countSubstrings"></a>countSubstrings</h1><img src="88.png" style="width:800px;"/>

<h2 id="countSubstrings-O-n-2"><a href="#countSubstrings-O-n-2" class="headerlink" title="countSubstrings() O(n^2)"></a>countSubstrings() O(n^2)</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># (start_pos, len)</span></span><br><span class="line">ret = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n - i + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">or</span> (i == <span class="number">2</span> <span class="keyword">and</span></span><br><span class="line">                      s[j] == s[j + <span class="number">1</span>]) <span class="keyword">or</span> (s[j] == s[j + i - <span class="number">1</span>] <span class="keyword">and</span></span><br><span class="line">                                            dp[j + <span class="number">1</span>][i - <span class="number">2</span>]):</span><br><span class="line">            dp[j][i] = <span class="number">1</span></span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h2 id="countSubstrings-Manacher’s-Algorithm-O-n"><a href="#countSubstrings-Manacher’s-Algorithm-O-n" class="headerlink" title="countSubstrings(Manacher’s Algorithm?) O(n)"></a>countSubstrings(Manacher’s Algorithm?) O(n)</h2><h1 id="dailyTemperatures-stack-O-n"><a href="#dailyTemperatures-stack-O-n" class="headerlink" title="dailyTemperatures(stack) O(n)"></a>dailyTemperatures(stack) O(n)</h1><img src="89.png" style="width:800px;"/>

<p>We use a stack to store the values. We push the value which is smaller than then top item of stack. Once we have a value which is larger than top item, we pop all values which are smaller than the current value and mark the result as [current position – item position].</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">T</span>):</span><br><span class="line">    ret = [<span class="number">0</span>] * <span class="built_in">len</span>(T)</span><br><span class="line">    stack = [(T[<span class="number">0</span>], <span class="number">0</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(T)):</span><br><span class="line">        top = stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> T[i] &gt; top[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> T[i] &gt; stack[-<span class="number">1</span>][<span class="number">0</span>]:</span><br><span class="line">                _t = stack.pop()</span><br><span class="line">                ret[_t[<span class="number">1</span>]] = i - _t[<span class="number">1</span>]</span><br><span class="line">        stack.append((T[i], i))</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Leetcode/" rel="tag">Leetcode</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/10/NLP-Summary/"
                    data-tooltip="NLP Summary"
                    aria-label="PREVIOUS: NLP Summary"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/05/21/magazine-review/"
                    data-tooltip="Magazine Review May 16th-22nd 2020"
                    aria-label="NEXT: Magazine Review May 16th-22nd 2020"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://joddiy.cc/2020/06/04/Leetcode/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://joddiy.cc/2020/06/04/Leetcode/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://joddiy.cc/2020/06/04/Leetcode/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 Joddiy Zhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/10/NLP-Summary/"
                    data-tooltip="NLP Summary"
                    aria-label="PREVIOUS: NLP Summary"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/05/21/magazine-review/"
                    data-tooltip="Magazine Review May 16th-22nd 2020"
                    aria-label="NEXT: Magazine Review May 16th-22nd 2020"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://joddiy.cc/2020/06/04/Leetcode/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=http://joddiy.cc/2020/06/04/Leetcode/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=http://joddiy.cc/2020/06/04/Leetcode/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=http://joddiy.cc/2020/06/04/Leetcode/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=http://joddiy.cc/2020/06/04/Leetcode/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=http://joddiy.cc/2020/06/04/Leetcode/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/14108933.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Joddiy Zhang</h4>
        
            <div id="about-card-bio"><p><a href="mailto:&#106;&#111;&#100;&#100;&#105;&#121;&#x7a;&#104;&#97;&#110;&#103;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;">&#106;&#111;&#100;&#100;&#105;&#121;&#x7a;&#104;&#97;&#110;&#103;&#x40;&#103;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#x6d;</a></p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Machine Learning Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Singapore
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-sqrh47zm5nkjgifq4rx38uvns4r2rarrrvwuhjxiztyrddruca5ukl7nw6br.min.js"></script>

<!--SCRIPTS END-->


    




    </body>
</html>
