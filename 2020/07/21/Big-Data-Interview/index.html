
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Jz Blog">
    <title>Big Data Interview - Jz Blog</title>
    <meta name="author" content="Joddiy Zhang">
    
    
        <link rel="icon" href="https://joddiy.github.io/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Joddiy Zhang","sameAs":["https://github.com/joddiy","https://scholar.google.com/citations?user=KH-xv38AAAAJ&hl=en&oi=sra","https://www.linkedin.com/in/joddiyzhang/"],"image":"14108933.jpeg"},"articleBody":"Hadoop关键技术\n数据分布在多台机器\n 可靠性：每个数据块都复制到多个节点\n 性能：多个节点同时处理数据\n\n计算随数据走\n 网络IO速度 &lt;&lt; 本地磁盘IO速度，大数据系统会尽量地将任务分配到离数据最近的机器上运行（程序运行时，将程序及其依赖包都复制到数据所在的机器运行）\n 代码向数据迁移，避免大规模数据时，造成大量数据迁移的情况，尽量让一段数据的计算发生在同一台机器上\n\n串行IO取代随机IO\n 传输时间 &lt;&lt; 寻道时间，一般数据写入后不再修改\n\nHadoop可运行于一般的商用服务器上，具有高容错、高可靠性、高扩展性等特点\n\n特别适合写一次，读多次的场景\n 适合: 大规模数据, 流式数据（写一次，读多次）, 商用硬件（一般硬件） 不适合: 低延时的数据访问, 大量的小文件, 频繁修改文件（基本就是写1次）\n\n\n\n列出Hadoop集群的Hadoop守护进程和相关的角色。\n\nBlock数据块;\n  基本存储单位，一般大小为64M（配置大的块主要是因为：1）减少搜寻时间，一般硬盘传输速率比寻道时间要快，大的块可以减少寻道时间；2）减少管理块的数据开销，每个块都需要在NameNode上有对应的记录；3）对数据块进行读写，减少建立网络的连接成本）\n  一个大文件会被拆分成一个个的块，然后存储于不同的机器。如果一个文件少于Block大小，那么实际占用的空间为其文件的大小\n  基本的读写单位，类似于磁盘的页，每次都是读写一个块\n  每个块都会被复制到多台机器，默认复制3份\n\nNameNode:\n  存储文件的metadata，运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小\n  一个Block在NameNode中对应一条记录（一般一个block占用150字节），如果是大量的小文件，会消耗大量内存。同时map task的数量是由splits来决定的，所以用MapReduce处理大量的小文件时，就会产生过多的map task，线程管理开销将会增加作业时间。处理大量小文件的速度远远小于处理同等大小的大文件的速度。因此Hadoop建议存储大文件\n  数据会定时保存到本地磁盘，但不保存block的位置信息，而是由DataNode注册时上报和运行时维护（NameNode中与DataNode相关的信息并不保存到NameNode的文件系统中，而是NameNode每次重启后，动态重建）\n  NameNode失效则整个HDFS都失效了，所以要保证NameNode的可用性\n\nSecondary NameNode：\n  定时与NameNode进行同步（定期合并文件系统镜像和编辑日志，然后把合并后的传给NameNode，替换其镜像，并清空编辑日志，类似于CheckPoint机制），但NameNode失效后仍需要手工将其设置成主机\n\nDataNode：\n  保存具体的block数据\n  负责数据的读写操作和复制操作\n  DataNode启动时会向NameNode报告当前存储的数据块信息，后续也会定时报告修改信息\n  DataNode之间会进行通信，复制数据块，保证数据的冗余性\n\n\nHadoop 新旧架构对比\n旧的MapReduce架构\n\nJobTracker：\n  这是运行在Namenode上，负责提交和跟踪MapReduce Job的守护程序。负责资源管理，跟踪资源消耗和可用性，作业生命周期管理（调度作业任务，跟踪进度，为任务提供容错）\n\nTaskTracker：\n  这是Datanode上运行的守护进程。它在Slave节点上负责具体任务的运行。\n\n旧框架存在问题：\n  JobTracker是MapReduce的集中处理点，存在单点故障\n  JobTracker完成了太多的任务，造成了过多的资源消耗，当MapReduce job 非常多的时候，会造成很大的内存开销。这也是业界普遍总结出老Hadoop的MapReduce只能支持4000 节点主机的上限\n  在TaskTracker端，以map&#x2F;reduce task的数目作为资源的表示过于简单，没有考虑到cpu&#x2F; 内存的占用情况，如果两个大内存消耗的task被调度到了一块，很容易出现OOM\n  在TaskTracker端，把资源强制划分为map task slot和reduce task slot, 如果当系统中只有map task或者只有reduce task的时候，会造成资源的浪费，也就集群资源利用的问题\n\n\n\nYARN就是将JobTracker的职责进行拆分，将资源管理和任务调度监控拆分成独立的进程：一个全局的资源管理和一个每个作业的管理（ApplicationMaster） ResourceManager和NodeManager提供了计算资源的分配和管理，而ApplicationMaster则完成应用程序的运行\n\nResourceManager: 全局资源管理和任务调度\n\nNodeManager: 单个节点的资源管理和监控\n\nApplicationMaster: 单个作业的资源管理和任务监控\n\nContainer: 资源申请的单位和任务运行的容器\n\n\n旧架构 基本流程\n\n\nYARN 基本流程\n\n\n\nJob submission\n 从ResourceManager中获取一个Application ID 检查作业输出配置，计算输入分片 拷贝作业资源（job jar、配置文件、分片信息）到HDFS，以便后面任务的执行\n\nJob initialization\n ResourceManager 将作业递交给 Scheduler（有很多调度算法，一般是根据优先级）Scheduler 为作业分配一个 Container， ResourceManager 就加载一个 application master process 并交给 NodeManager 管理, ApplicationMaster 主要是创建一系列的监控进程来跟踪作业的进度，同时获取输入分片，为每一个分片创建一个 Map task 和相应的 reduce task 。 Application Master 还决定如何运行作业，如果作业很小（可配置），则直接在同一个JVM下运行\n\nTask assignment\n ApplicationMaster 向Resource Manager 申请资源（一个个的Container，指定任务分配的资源要求）一般是根据 data locality 来分配资源\n\nTask execution\n Application Master 根据 ResourceManager 的分配情况，在对应的 NodeManager 中启动 Container 。从 HDFS 读取任务所需资源（job jar，配置文件等），然后执行该任务\n\nProgress and status update\n 定时将任务的进度和状态报告给 ApplicationMaster， Client 定时向 ApplicationMaster 获取整个任务的进度和状态\n\nJob completion\n Client 定时检查整个作业是否完成 作业完成后，会清空临时文件、目录等\n\n\nYarn Failover\n任务失败\n 运行时异常或者JVM退出都会报告给 ApplicationMaster\n 通过心跳来检查挂住的任务(timeout)，会检查多次（可配置）才判断该任务是否失效\n 一个作业的任务失败率超过配置，则认为该作业失败\n 失败的任务或作业都会有 ApplicationMaster 重新运行\n\nApplicationMaster 失败\n ApplicationMaster 定时发送心跳信号到 ResourceManager，通常一旦 ApplicationMaster 失败，则认为失败，但也可以通过配置多次后才失败\n 一旦 ApplicationMaster 失败，ResourceManager 会启动一个新的 ApplicationMaster\n 新的 ApplicationMaster 负责恢复之前错误的 ApplicationMaster 的状态 (yarn.app.mapreduce.am.job.recovery.enable&#x3D;true)，这一步是通过将应用运行状态保存到共享的存储上来实现的，ResourceManager 不会负责任务状态的保存和恢复\n Client也会定时向 ApplicationMaster 查询进度和状态，一旦发现其失败，则向 ResouceManager 询问新的 ApplicationMaster\n\nNodeManager失败\n NodeManager 定时发送心跳到 ResourceManager，如果超过一段时间没有收到心跳消息，ResourceManager 就会将其移除\n 任何运行在该 NodeManager 上的任务和 ApplicationMaster 都会在其他 NodeManager 上进行恢复\n 如果某个 NodeManager 失败的次数太多，ApplicationMaster 会将其加入黑名单（ResourceManager没有），任务调度时不在其上运行任务\n\nResourceManager失败\n 通过 checkpoint 机制，定时将其状态保存到磁盘，然后失败的时候，重新运行\n 通过 zookeeper 同步状态和实现透明的 High Available\n\n\n可以看出，一般的错误处理都是由当前模块的父模块进行监控（心跳）和恢复。而最顶端的模块则通过定时保存、同步状态和 zookeeper 来ֹ实现 HA\nZookeeperZookeeper： 为分布式应用提供分布式协作（协调）服务。使用类似文件系统的树形结构。目的是分布式服务不再需要由于协作冲突而另外实现协作服务。\nZookeeper集群统一为其他分布式应用（也是集群，例如HDFS集群、Yarn集群等等）集群提供协作服务。\n\nZookeeper 的节点名称叫做 znode，以路径标注， 每个节点存储上限是 1MB。数据访问是原子的。\nznode 有临时性和永久性之分。临时性 znode 在客户端会话结束后删除。临时性 znode 对所有客户端也是可见的。\n一个顺序的 znode 由 Zookeeper 给定一个序号作为其名称一部分，如’&#x2F;a&#x2F;b-3’，3 即为指定的序号。可用来实现分布式锁。\nWatch 在 znode 变更时通知客户端。客户端调用 znode 读操作时会同时获得一个 Watch，当 znode 发生写操作时，此 Watch 会被通知一次且仅一次。\n更新 znode 必须声明版本号（乐观锁），如果版本号错误则更新失败，可指定版本号为 -1 进行强制更新。\nZookeeper 抛弃了文件系统的操作原语，因为文件非常小且整体读写，所以不需要打开、关闭、寻址操作。\n支持 同步 和 异步 两种 API。\nznode 维护一个 ACL 列表，决定谁可以访问那些操作。\nZookeeper 运行在一组叫做 ensemble 的集群上，服务器数量是奇数个，2N+1， N代表允许宕机的个数。\n\nZookeeper角色：Leader， Follower， Client\nZookeeper 采用 Zab 协议，分两个阶段：\n\n领导者选举，且要求大部分更随者同领导者同步状态。\n\n原子广播，所有写操作被传送给领导者，并通过广播将更新信息告诉跟随者，当大部分跟随者都同步了写操作，则返回成功给客户端。\n\n\n每次写操作都有一个唯一全局标识，zxid，按先后顺序排序。所有的更新都是，顺序的，原子的，单系统镜像的，容错的，合时的（不过太过时）。\n读操作由内存提供，可能读到过时信息，可调用 sync 强制同领导者同步。\ntick time 是基本时长，其他时间均为该时间倍数。\n案例：\n\n配置服务：每次读操作获得一个 Watch，在更新时被通知，重新读即可。\n\n分布式锁：指明一个lock znode，所有客户端在该 znode下创建临时 znode，拥有最小序列号的 znode 获得锁。避免链接丢失而重复创建锁，获得锁时，应检查属于该客户会话的锁是否存在。\n\n\nHadoop 读取数据通过 InputFormat 决定读取的数据的类型，然后拆分成一个个 InputSplit ，每个 InputSplit 对应一个 Map 处理，RecordReader 读取 InputSplit 的内容给 Map。\nInputSplit 代表一个个逻辑分片，并没有真正存储数据，只是提供了一个如何将数据分片的方法，Split 内有 获取长度和位置的方法，长度可排序大的先执行，位置利于数据局部化。\nRecordReader 将 InputSplit 拆分成一个个 key, value 对给 Map 处理\n大量小文件如何处理：CombineFileInputFormat 可以将若干个 Split 打包成一个\n通常一个 split 就是一个 block，这样做的好处是使得 Map 可以在存储有当前数据的节点上运行本地的任务，而不需要通过网络进行跨节点的任务调度\n通过 mapred.min.split.size， mapred.max.split.size, block.size 来控制拆分的大小\n\n分片间的数据如何处理：忽略最后一条记录，后一个split远程读该条记录\nHDFS不适用场景：低延迟访问，大量小文件，多用户写入。HDFS文件只有一个写入者，且总是在文件末尾。\nHDFS中小于 64M 时不会占用整块空间，大容量块是为了减少寻址开销。\nNamenode高可用：写入本地同时写入一个 NFS 挂载，第二Namenode\nJAVA 接口：\n12345678910111213141516171819202122232425// URLURL.setURLStreamHandlerFactory(new FsUrlStreamHandlerFactory());InputStream in  = new URL(&quot;..&quot;).openStream();IOUtils.copyBytes(in, System.out, 4096, false);//FileSystem APIFileSystem fs = FileSystem.get(URI.create(&quot;..&quot;), conf);fs.oepn(new Path(&quot;..&quot;)) // return a FSDataInputStream, 支持随机访问和获取当前位置//写入FileSystem fs = FileSystem.get(URI.create(&quot;..&quot;), conf);OutputStream out = fs.create(new Path(&quot;..&quot;), new Progressable()&#123;&#125;); // return a FSDataOutputStream, 支持获取当前位置IOUtils.copyBytes(in, out, 4096, true);fs.mkdirs(Path);fs.exists(Path);fs.getFileStatus(Path);fs.listStatus(Path);fs.globStatus(Path, PathFilter); // 返回路径上匹配的文件fs.delete(Path, boolean recursive);\n\nHDFS 读取数据\n\nNamenode 只提供索引，不提供数据。错误时跳过，损坏时读副本。检查校验和。\n网络拓扑\n\nHDFS 写入数据\n\n如果某datanode失败，会重新执行确认队列中的数据，且向namenode注册新身份，跳过故障节点。\n写入副本的放置\n\n一致模型：写入一个块即可看到该块，如果要同步读取，调用 sync() 方法。\ndistcp 分布式复制，多线程，两个 HDFS 之间传输。以 MapReduce 方式进行，只有 Map。\nHadoop Archives: 多个小文件合并成 .har 存储。以副本方式归档、归档后不可修改。\nHadoop I&#x2F;OCRC-32 校验和，每512字节计算32字节。\n压缩Gzip，ZIP，bzip2，LZO。CompressionCodec 编码器，使用 native library 加速。CodecPool 编码器池。\n压缩后无法分割，造成一个 map 处理多个块，无法数据本地化。\n序列划：\n\nWritable 接口，write(DataOutput) 和 readFields(DataInput) 方法。\n两个比较器，Writable 接口和RawComparator 接口。前者对象比较 CompareTo(A, B)，后者字节比较 compare(byte[], int, int, byte[], int, int)，默认的 compare 的实现会调用 compareTo， 因此也会反序列化成对象。\n\nWritable 类：BooleanWritable, ByteWritable, IntWritable, VIntWritable, FloatWritable, LongWritable, VLongWritable, DoubleWritable.\nText: 严格按照字节寻址，unicode会拆成两个地址。\nNullWritable: 单实例，除此之外，其他 Writable 都可以修改。\nObjectWritable：可封装多种类型。\nGenericWritable：可封装多种类型，但通过数组索引指明类型。\nWritable集合：ArrayWritbale，TwoDArrayWritable，MapWritable，SortedMapWritable。数组，二维数字，Map，sortedMap。\nHashPartitioner 使用 writable 中的 hashCode() 方法来选择分区。\nSequenceFile：用来打包多个小文件，读取提供，next()，getCurrentValue() 方法。seek() 可定位，但不是记录边界时会出错，可用 sync() 定位到下一个同步点。文件为 name.seq。\nMapFile：经过排序带有索引的 SequenceFile。文件为 name.map。其中包含一个 index 和一个 data 文件。index 中只保留部分索引，提供 get() 和 getClost() 读取方法。可用 fix() 方法重建索引，或者从 SequenceFile 转为 MapFile。\nHadoop 测试对 Map 和 Reduce 单元测试\n本地作业上测试驱动程序，MiniDFSCluster 和 MiniMRCluster 测试。\n远程调试：设置 keep.failed.task.files 为 true，保存失败任务输入，登录目标节点，用 IsolationRunner 再次执行。\nShuffle 和 排序Map 端：缓冲区 100M，超过 80% 开始内存溢写，分区，且分区内排序，排序后执行combiner，多个溢写文件会合并，少于3个不合并。可压缩。\nReduce 端：\n\n复制阶段：5个线程复制，先复制到内存，超出阈值溢写到磁盘。需解压。\n排序阶段：根据合并系数进行合并，可能最后有多个文件。\nreduce 阶段：多个文件输入 reduce 函数。\n\n优化原则：为 shuffle 指定更多空间，避免多次磁盘溢写。对于Map，主要就是避免把文件写入磁盘，例如使用 Combiner，增大 io.sort.mb 的值。对于 Reduce ，主要是把 Map 的结果尽可能地保存到内存中，同样也是要避免把中间结果写入磁盘。默认情况下，所有的内存都是分配给 Reduce 方法的。使用压缩，增大buffer size。\n任务执行speculative execution， 某个任务过慢，开启相同任务作为备份，谁先完成用谁，另外一个则终止。\nJVM 重用\n跳过坏记录：skipping 模式，失败两次后，第三次失败则记录并跳过。\n多个实例向同一个文件写：先写入临时文件夹，先完成的允许修改。\nHadoop 流格式Input:\n\nFileInputFormat，过滤隐藏文件，分割原则：max(min_split, min(max_split, block_size))\nCombineFileInputFormat，把多个小文件打包到一个输入中。\nTextInputForamt\nKeyValueTextInputForamt，第一个 tab 分开 key 和 value\nNLineInputForamt，指定每个 map 收到多少行\nSteamInputForamt, 处理 XML\nSequenceFileInputForamt，可处理 SequenceFile\nSequenceFileAsTextInputForamt，键值变成 Text\nSequenceFileAsBinaryInputForamt，键值变成 Binary\nMultipleInputs，在每一个路径上规定 Format\nDBInputFormat\n\nOutput:\n\nTextOutputForamt\nSequenceFileOutputForamt\nSequenceFileAsBinaryOutputForamt\nMapFileOutputForamt\nMltipleOutputFormat, 可控制文件名\nMultipleOutpus，文件名后跟’-r-分区索引’，但灵活，功能多\nLazyOutputForamt，有记录时才写文件，避免空文件\n\n计数器任务失败计数器可能减少。枚举定义计数器，也可以用组名定义动态计数器。可通过 Web 界面，命令行 和 JAVA API 获取计数器。\n排序\n部分排序：利用 MapReduce，\n部分排序查找：输出变为 MapFile\n全局排序：partition 对 key 从小到大分区，利用采样器 Sampler 均匀分区，partition 文件写入分布式缓存全局共享。\n二次排序：复合键，单键分区（到同一个reduce），单键分组（到同一组，setOutputValueGroupingComparator），自定义 comparator，按照双键排序（setOutputKeyComparatorClass）。\n\npython 流中，可用 KeyFieldBasedPartitioner 进行单键分割，用 KeyFiledBasedComparator 比较双键比较。\n链接速度 全内存链接 &gt; 部分内存链接 &gt; MapReduce\n\nMap 端：要求严格，用来链接多个作业输出，相同数量reducer，相同键，输出文件不可分。\nReduce 端：比如 1对多 链接，左半部分 key 为（链接键，0），右半部分 key 为（链接键，1），分区分组都按照连接键进行，0 和 1 保证了到达的先后顺序。\n\n分布式缓存使用 -files -archives，让APPlicationMaster直接去拷贝。引用计数和缓存清理。\n或者通过API，addCacheFile() 和 addCacheArchive() 去指定拷贝。添加 symlink 符号链接。\n增加和移除节点\n\nPig\nHbaseHbase 是一个分布的，面向列的，排序的 map 存储。\n基于Google Bigtable的开源实现，是一个具有高可靠性、高性能、面向列、可伸缩性、典型的key&#x2F;value分布式存储的nosql数据库系统，主要用于海量结构化和半结构化数据存储。它介于nosql和RDBMS之间，仅能通过行键（row key）和行键的range来检索数据，行数据存储是原子性的，仅支持单行事务（可通过hive支持来实现多表join等复杂操作）。HBase查询数据功能很简单，不支持join等复杂操作，不支持跨行和跨表事务\n单元格内容为无解释的字节数组，行键也是字节数组，表以行键排序。面向列族的存储。\n把表按照行切分成区域，区域分散在 HBase 集群上。\n行级事务，行的更新时原子的。\n两个目录表，-ROOT- 表包含 .META. 表所在区域。.META. 表包含所有用户空间区域列表。\n区域自动平衡。\n\nHiveHive 中存放是表，是和 hdfs 的映射关系，hive 是逻辑上的数据仓库，实际操作的都是 hdfs 上的文件，HQL 就是用 sql 语法来写的 mr 程序。\nHive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供HQL语句（类SQL语言）查询功能，存储依赖于HDFS。支持多种计算引擎，如Spark、MapReduce（默认）、Tez；支持多种存储格式，如TextFile、SequenceFile、RCFile、ORC、Parquet（常用）；支持多种压缩格式，如gzip、lzo、snappy（常用）、bzip2\nSqoophadoop生态圈上的数据传输工具。\n可以将关系型数据库的数据导入非结构化的hdfs、hive或者bbase中，也可以将hdfs中的数据导出到关系型数据库或者文本文件中。\n使用的是mr程序来执行任务，使用jdbc和关系型数据库进行交互。\nFlumeFlume 一个分布式、可靠的、高可用的用于数据采集、聚合和传输的系统。常用于日志采集系统中，支持定制各类数据发送方用于收集数据、通过自定义拦截器对数据进行简单的预处理并传输到各种数据接收方如HDFS、HBase、Kafka中。之前由Cloudera开发，后纳入Apache\nALS, canopy, 朴素贝叶斯分类, aprioriSparkSpark是一个快速、通用、可扩展、可容错的、内存迭代式计算的大数据分析引擎。目前生态体系主要包括用于批数据处理的SparkRDD、SparkSQL，用于流数据处理的SparkStreaming、Structured-Streaming，用于机器学习的Spark MLLib，用于图计算的Graphx以及用于统计分析的SparkR，支持Java、Scala、Python、R多种数据语言\n","dateCreated":"2020-07-21T03:05:19+08:00","dateModified":"2020-07-21T03:05:19+08:00","datePublished":"2020-07-21T03:05:19+08:00","description":"Study notes of C++","headline":"Big Data Interview","image":["https://cdn.iconscout.com/icon/free/png-256/hadoop-226007.png","https://www.itprotoday.com/sites/itprotoday.com/files/styles/article_featured_retina/public/Hadoop.jpg?itok=QV5Fhtnr"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://joddiy.github.io/2020/07/21/Big-Data-Interview/"},"publisher":{"@type":"Organization","name":"Joddiy Zhang","sameAs":["https://github.com/joddiy","https://scholar.google.com/citations?user=KH-xv38AAAAJ&hl=en&oi=sra","https://www.linkedin.com/in/joddiyzhang/"],"image":"14108933.jpeg","logo":{"@type":"ImageObject","url":"14108933.jpeg"}},"url":"https://joddiy.github.io/2020/07/21/Big-Data-Interview/","keywords":"Big data, Hadoop","thumbnailUrl":"https://cdn.iconscout.com/icon/free/png-256/hadoop-226007.png"}</script>
    <meta name="description" content="Study notes of C++">
<meta property="og:type" content="blog">
<meta property="og:title" content="Big Data Interview">
<meta property="og:url" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/index.html">
<meta property="og:site_name" content="Jz Blog">
<meta property="og:description" content="Study notes of C++">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/wk/hadoop/architecture.png">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/20190627/1561603936683523.png">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/20170808/1502171952954287.jpg">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/20170808/1502172142576437.jpg">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/1.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/2.png">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/20170808/1502172265232242.jpg">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/20170808/1502172265232242.jpg">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/3.jpg">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/4.jpg">
<meta property="og:image" content="https://atts.w3cschool.cn/attachments/image/wk/hadoop/mapreduce-split.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/5.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/7.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/6.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/8.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/9.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/10.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/11.png">
<meta property="og:image" content="https://joddiy.github.io/2020/07/21/Big-Data-Interview/12.png">
<meta property="article:published_time" content="2020-07-20T19:05:19.000Z">
<meta property="article:modified_time" content="2020-07-20T19:05:19.000Z">
<meta property="article:author" content="Joddiy Zhang">
<meta property="article:tag" content="Big data">
<meta property="article:tag" content="Hadoop">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atts.w3cschool.cn/attachments/image/wk/hadoop/architecture.png">
    
    
        
    
    
        <meta property="og:image" content="https://joddiy.github.io/assets/images/14108933.jpeg"/>
    
    
        <meta property="og:image" content="https://cdn.iconscout.com/icon/free/png-256/hadoop-226007.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://cdn.iconscout.com/icon/free/png-256/hadoop-226007.png"/>
    
    
        <meta property="og:image" content="https://www.itprotoday.com/sites/itprotoday.com/files/styles/article_featured_retina/public/Hadoop.jpg?itok=QV5Fhtnr"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://www.itprotoday.com/sites/itprotoday.com/files/styles/article_featured_retina/public/Hadoop.jpg?itok=QV5Fhtnr"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-x8blglznjjnb9pnnwui5zw4h43ysufmsh1b0omicawm4vhqcutzqavokgpne.min.css">

    <!--STYLES END-->
    

    

    
        
            
<link rel="stylesheet" href="/assets/css/gitalk.css">

        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Jz Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="Open the link: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/14108933.jpeg" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="Read more about the author"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/14108933.jpeg" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Joddiy Zhang</h4>
                
                    <h5 class="sidebar-profile-bio"><p><a href="mailto:&#106;&#111;&#100;&#100;&#x69;&#121;&#x7a;&#104;&#97;&#110;&#x67;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;">&#106;&#111;&#100;&#100;&#x69;&#121;&#x7a;&#104;&#97;&#110;&#x67;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a></p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="Categories"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="Tags"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="Archives"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/joddiy"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://scholar.google.com/citations?user=KH-xv38AAAAJ&hl=en&oi=sra"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Google Scholar"
                        >
                        <i class="sidebar-button-icon fab fa-google" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google Scholar</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/in/joddiyzhang/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--partial"
             style="background-image:url('https://www.itprotoday.com/sites/itprotoday.com/files/styles/article_featured_retina/public/Hadoop.jpg?itok=QV5Fhtnr');"
             data-behavior="4">
            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaOut
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Big Data Interview
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2020-07-21T03:05:19+08:00">
	
		    Jul 21, 2020
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Study-Notes/">Study Notes</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><h2 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h2><ol>
<li><p>数据分布在多台机器</p>
<p> 可靠性：每个数据块都复制到多个节点</p>
<p> 性能：多个节点同时处理数据</p>
</li>
<li><p>计算随数据走</p>
<p> 网络IO速度 &lt;&lt; 本地磁盘IO速度，大数据系统会尽量地将任务分配到离数据最近的机器上运行（程序运行时，将程序及其依赖包都复制到数据所在的机器运行）</p>
<p> 代码向数据迁移，避免大规模数据时，造成大量数据迁移的情况，尽量让一段数据的计算发生在同一台机器上</p>
</li>
<li><p>串行IO取代随机IO</p>
<p> 传输时间 &lt;&lt; 寻道时间，一般数据写入后不再修改</p>
</li>
<li><p>Hadoop可运行于一般的商用服务器上，具有高容错、高可靠性、高扩展性等特点</p>
</li>
<li><p>特别适合写一次，读多次的场景</p>
<p> 适合: 大规模数据, 流式数据（写一次，读多次）, 商用硬件（一般硬件）<br> 不适合: 低延时的数据访问, 大量的小文件, 频繁修改文件（基本就是写1次）</p>
</li>
</ol>
<p><img src="https://atts.w3cschool.cn/attachments/image/wk/hadoop/architecture.png"></p>
<h2 id="列出Hadoop集群的Hadoop守护进程和相关的角色。"><a href="#列出Hadoop集群的Hadoop守护进程和相关的角色。" class="headerlink" title="列出Hadoop集群的Hadoop守护进程和相关的角色。"></a>列出Hadoop集群的Hadoop守护进程和相关的角色。</h2><p><img src="https://atts.w3cschool.cn/attachments/image/20190627/1561603936683523.png"></p>
<ul>
<li><p>Block数据块;</p>
<p>  基本存储单位，一般大小为64M（配置大的块主要是因为：1）减少搜寻时间，一般硬盘传输速率比寻道时间要快，大的块可以减少寻道时间；2）减少管理块的数据开销，每个块都需要在NameNode上有对应的记录；3）对数据块进行读写，减少建立网络的连接成本）</p>
<p>  一个大文件会被拆分成一个个的块，然后存储于不同的机器。如果一个文件少于Block大小，那么实际占用的空间为其文件的大小</p>
<p>  基本的读写单位，类似于磁盘的页，每次都是读写一个块</p>
<p>  每个块都会被复制到多台机器，默认复制3份</p>
</li>
<li><p>NameNode:</p>
<p>  存储文件的metadata，运行时所有数据都保存到内存，整个HDFS可存储的文件数受限于NameNode的内存大小</p>
<p>  一个Block在NameNode中对应一条记录（一般一个block占用150字节），如果是大量的小文件，会消耗大量内存。同时map task的数量是由splits来决定的，所以用MapReduce处理大量的小文件时，就会产生过多的map task，线程管理开销将会增加作业时间。处理大量小文件的速度远远小于处理同等大小的大文件的速度。因此Hadoop建议存储大文件</p>
<p>  数据会定时保存到本地磁盘，但不保存block的位置信息，而是由DataNode注册时上报和运行时维护（NameNode中与DataNode相关的信息并不保存到NameNode的文件系统中，而是NameNode每次重启后，动态重建）</p>
<p>  NameNode失效则整个HDFS都失效了，所以要保证NameNode的可用性</p>
</li>
<li><p>Secondary NameNode：</p>
<p>  定时与NameNode进行同步（定期合并文件系统镜像和编辑日志，然后把合并后的传给NameNode，替换其镜像，并清空编辑日志，类似于CheckPoint机制），但NameNode失效后仍需要手工将其设置成主机</p>
</li>
<li><p>DataNode：</p>
<p>  保存具体的block数据</p>
<p>  负责数据的读写操作和复制操作</p>
<p>  DataNode启动时会向NameNode报告当前存储的数据块信息，后续也会定时报告修改信息</p>
<p>  DataNode之间会进行通信，复制数据块，保证数据的冗余性</p>
</li>
</ul>
<h2 id="Hadoop-新旧架构对比"><a href="#Hadoop-新旧架构对比" class="headerlink" title="Hadoop 新旧架构对比"></a>Hadoop 新旧架构对比</h2><p><img src="https://atts.w3cschool.cn/attachments/image/20170808/1502171952954287.jpg"></p>
<p>旧的MapReduce架构</p>
<ul>
<li><p>JobTracker：</p>
<p>  这是运行在Namenode上，负责提交和跟踪MapReduce Job的守护程序。负责资源管理，跟踪资源消耗和可用性，作业生命周期管理（调度作业任务，跟踪进度，为任务提供容错）</p>
</li>
<li><p>TaskTracker：</p>
<p>  这是Datanode上运行的守护进程。它在Slave节点上负责具体任务的运行。</p>
</li>
<li><p>旧框架存在问题：</p>
<p>  JobTracker是MapReduce的集中处理点，存在单点故障</p>
<p>  JobTracker完成了太多的任务，造成了过多的资源消耗，当MapReduce job 非常多的时候，会造成很大的内存开销。这也是业界普遍总结出老Hadoop的MapReduce只能支持4000 节点主机的上限</p>
<p>  在TaskTracker端，以map&#x2F;reduce task的数目作为资源的表示过于简单，没有考虑到cpu&#x2F; 内存的占用情况，如果两个大内存消耗的task被调度到了一块，很容易出现OOM</p>
<p>  在TaskTracker端，把资源强制划分为map task slot和reduce task slot, 如果当系统中只有map task或者只有reduce task的时候，会造成资源的浪费，也就集群资源利用的问题</p>
</li>
</ul>
<p><img src="https://atts.w3cschool.cn/attachments/image/20170808/1502172142576437.jpg"></p>
<p>YARN就是将JobTracker的职责进行拆分，将资源管理和任务调度监控拆分成独立的进程：一个全局的资源管理和一个每个作业的管理（ApplicationMaster） ResourceManager和NodeManager提供了计算资源的分配和管理，而ApplicationMaster则完成应用程序的运行</p>
<ul>
<li><p>ResourceManager: 全局资源管理和任务调度</p>
</li>
<li><p>NodeManager: 单个节点的资源管理和监控</p>
</li>
<li><p>ApplicationMaster: 单个作业的资源管理和任务监控</p>
</li>
<li><p>Container: 资源申请的单位和任务运行的容器</p>
</li>
</ul>
<p>旧架构 基本流程</p>
<p><img src="/2020/07/21/Big-Data-Interview/1.png"></p>
<p><img src="/2020/07/21/Big-Data-Interview/2.png"></p>
<p>YARN 基本流程</p>
<p><img src="https://atts.w3cschool.cn/attachments/image/20170808/1502172265232242.jpg"></p>
<p><img src="https://atts.w3cschool.cn/attachments/image/20170808/1502172265232242.jpg"></p>
<ol>
<li><p>Job submission</p>
<p> 从ResourceManager中获取一个Application ID 检查作业输出配置，计算输入分片 拷贝作业资源（job jar、配置文件、分片信息）到HDFS，以便后面任务的执行</p>
</li>
<li><p>Job initialization</p>
<p> ResourceManager 将作业递交给 Scheduler（有很多调度算法，一般是根据优先级）Scheduler 为作业分配一个 Container， ResourceManager 就加载一个 application master process 并交给 NodeManager 管理, ApplicationMaster 主要是创建一系列的监控进程来跟踪作业的进度，同时获取输入分片，为每一个分片创建一个 Map task 和相应的 reduce task 。 Application Master 还决定如何运行作业，如果作业很小（可配置），则直接在同一个JVM下运行</p>
</li>
<li><p>Task assignment</p>
<p> ApplicationMaster 向Resource Manager 申请资源（一个个的Container，指定任务分配的资源要求）一般是根据 data locality 来分配资源</p>
</li>
<li><p>Task execution</p>
<p> Application Master 根据 ResourceManager 的分配情况，在对应的 NodeManager 中启动 Container 。从 HDFS 读取任务所需资源（job jar，配置文件等），然后执行该任务</p>
</li>
<li><p>Progress and status update</p>
<p> 定时将任务的进度和状态报告给 ApplicationMaster， Client 定时向 ApplicationMaster 获取整个任务的进度和状态</p>
</li>
<li><p>Job completion</p>
<p> Client 定时检查整个作业是否完成 作业完成后，会清空临时文件、目录等</p>
</li>
</ol>
<h2 id="Yarn-Failover"><a href="#Yarn-Failover" class="headerlink" title="Yarn Failover"></a>Yarn Failover</h2><ol>
<li><p>任务失败</p>
<p> 运行时异常或者JVM退出都会报告给 ApplicationMaster</p>
<p> 通过心跳来检查挂住的任务(timeout)，会检查多次（可配置）才判断该任务是否失效</p>
<p> 一个作业的任务失败率超过配置，则认为该作业失败</p>
<p> 失败的任务或作业都会有 ApplicationMaster 重新运行</p>
</li>
<li><p>ApplicationMaster 失败</p>
<p> ApplicationMaster 定时发送心跳信号到 ResourceManager，通常一旦 ApplicationMaster 失败，则认为失败，但也可以通过配置多次后才失败</p>
<p> 一旦 ApplicationMaster 失败，ResourceManager 会启动一个新的 ApplicationMaster</p>
<p> 新的 ApplicationMaster 负责恢复之前错误的 ApplicationMaster 的状态 (yarn.app.mapreduce.am.job.recovery.enable&#x3D;true)，这一步是通过将应用运行状态保存到共享的存储上来实现的，ResourceManager 不会负责任务状态的保存和恢复</p>
<p> Client也会定时向 ApplicationMaster 查询进度和状态，一旦发现其失败，则向 ResouceManager 询问新的 ApplicationMaster</p>
</li>
<li><p>NodeManager失败</p>
<p> NodeManager 定时发送心跳到 ResourceManager，如果超过一段时间没有收到心跳消息，ResourceManager 就会将其移除</p>
<p> 任何运行在该 NodeManager 上的任务和 ApplicationMaster 都会在其他 NodeManager 上进行恢复</p>
<p> 如果某个 NodeManager 失败的次数太多，ApplicationMaster 会将其加入黑名单（ResourceManager没有），任务调度时不在其上运行任务</p>
</li>
<li><p>ResourceManager失败</p>
<p> 通过 checkpoint 机制，定时将其状态保存到磁盘，然后失败的时候，重新运行</p>
<p> 通过 zookeeper 同步状态和实现透明的 High Available</p>
</li>
</ol>
<p>可以看出，一般的错误处理都是由当前模块的父模块进行监控（心跳）和恢复。而最顶端的模块则通过定时保存、同步状态和 zookeeper 来ֹ实现 HA</p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Zookeeper： 为分布式应用提供分布式协作（协调）服务。使用类似文件系统的树形结构。目的是分布式服务不再需要由于协作冲突而另外实现协作服务。</p>
<p>Zookeeper集群统一为其他分布式应用（也是集群，例如HDFS集群、Yarn集群等等）集群提供协作服务。</p>
<p><img src="/2020/07/21/Big-Data-Interview/3.jpg"></p>
<p>Zookeeper 的节点名称叫做 znode，以路径标注， 每个节点存储上限是 1MB。数据访问是原子的。</p>
<p>znode 有临时性和永久性之分。临时性 znode 在客户端会话结束后删除。临时性 znode 对所有客户端也是可见的。</p>
<p>一个顺序的 znode 由 Zookeeper 给定一个序号作为其名称一部分，如’&#x2F;a&#x2F;b-3’，3 即为指定的序号。可用来实现分布式锁。</p>
<p>Watch 在 znode 变更时通知客户端。客户端调用 znode 读操作时会同时获得一个 Watch，当 znode 发生写操作时，此 Watch 会被通知一次且仅一次。</p>
<p>更新 znode 必须声明版本号（乐观锁），如果版本号错误则更新失败，可指定版本号为 -1 进行强制更新。</p>
<p>Zookeeper 抛弃了文件系统的操作原语，因为文件非常小且整体读写，所以不需要打开、关闭、寻址操作。</p>
<p>支持 同步 和 异步 两种 API。</p>
<p>znode 维护一个 ACL 列表，决定谁可以访问那些操作。</p>
<p>Zookeeper 运行在一组叫做 ensemble 的集群上，服务器数量是奇数个，2N+1， N代表允许宕机的个数。</p>
<p><img src="/2020/07/21/Big-Data-Interview/4.jpg"></p>
<p>Zookeeper角色：Leader， Follower， Client</p>
<p>Zookeeper 采用 Zab 协议，分两个阶段：</p>
<ol>
<li><p>领导者选举，且要求大部分更随者同领导者同步状态。</p>
</li>
<li><p>原子广播，所有写操作被传送给领导者，并通过广播将更新信息告诉跟随者，当大部分跟随者都同步了写操作，则返回成功给客户端。</p>
</li>
</ol>
<p>每次写操作都有一个唯一全局标识，zxid，按先后顺序排序。所有的更新都是，顺序的，原子的，单系统镜像的，容错的，合时的（不过太过时）。</p>
<p>读操作由内存提供，可能读到过时信息，可调用 sync 强制同领导者同步。</p>
<p>tick time 是基本时长，其他时间均为该时间倍数。</p>
<p>案例：</p>
<ol>
<li><p>配置服务：每次读操作获得一个 Watch，在更新时被通知，重新读即可。</p>
</li>
<li><p>分布式锁：指明一个lock znode，所有客户端在该 znode下创建临时 znode，拥有最小序列号的 znode 获得锁。避免链接丢失而重复创建锁，获得锁时，应检查属于该客户会话的锁是否存在。</p>
</li>
</ol>
<h2 id="Hadoop-读取数据"><a href="#Hadoop-读取数据" class="headerlink" title="Hadoop 读取数据"></a>Hadoop 读取数据</h2><p>通过 InputFormat 决定读取的数据的类型，然后拆分成一个个 InputSplit ，每个 InputSplit 对应一个 Map 处理，RecordReader 读取 InputSplit 的内容给 Map。</p>
<p>InputSplit 代表一个个逻辑分片，并没有真正存储数据，只是提供了一个如何将数据分片的方法，Split 内有 获取长度和位置的方法，长度可排序大的先执行，位置利于数据局部化。</p>
<p>RecordReader 将 InputSplit 拆分成一个个 key, value 对给 Map 处理</p>
<p>大量小文件如何处理：CombineFileInputFormat 可以将若干个 Split 打包成一个</p>
<p>通常一个 split 就是一个 block，这样做的好处是使得 Map 可以在存储有当前数据的节点上运行本地的任务，而不需要通过网络进行跨节点的任务调度</p>
<p>通过 mapred.min.split.size， mapred.max.split.size, block.size 来控制拆分的大小</p>
<p><img src="https://atts.w3cschool.cn/attachments/image/wk/hadoop/mapreduce-split.png"></p>
<p>分片间的数据如何处理：忽略最后一条记录，后一个split远程读该条记录</p>
<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>不适用场景：低延迟访问，大量小文件，多用户写入。HDFS文件只有一个写入者，且总是在文件末尾。</p>
<p>HDFS中小于 64M 时不会占用整块空间，大容量块是为了减少寻址开销。</p>
<p>Namenode高可用：写入本地同时写入一个 NFS 挂载，第二Namenode</p>
<p>JAVA 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL</span></span><br><span class="line">URL.setURLStreamHandlerFactory(<span class="keyword">new</span> <span class="title class_">FsUrlStreamHandlerFactory</span>());</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;..&quot;</span>).openStream();</span><br><span class="line">IOUtils.copyBytes(in, System.out, <span class="number">4096</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//FileSystem API</span></span><br><span class="line"><span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystem.get(URI.create(<span class="string">&quot;..&quot;</span>), conf);</span><br><span class="line">fs.oepn(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;..&quot;</span>)) <span class="comment">// return a FSDataInputStream, 支持随机访问和获取当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入</span></span><br><span class="line"><span class="type">FileSystem</span> <span class="variable">fs</span> <span class="operator">=</span> FileSystem.get(URI.create(<span class="string">&quot;..&quot;</span>), conf);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> fs.create(<span class="keyword">new</span> <span class="title class_">Path</span>(<span class="string">&quot;..&quot;</span>), <span class="keyword">new</span> <span class="title class_">Progressable</span>()&#123;&#125;); <span class="comment">// return a FSDataOutputStream, 支持获取当前位置</span></span><br><span class="line">IOUtils.copyBytes(in, out, <span class="number">4096</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdirs(Path);</span><br><span class="line"></span><br><span class="line">fs.exists(Path);</span><br><span class="line"></span><br><span class="line">fs.getFileStatus(Path);</span><br><span class="line"></span><br><span class="line">fs.listStatus(Path);</span><br><span class="line"></span><br><span class="line">fs.globStatus(Path, PathFilter); <span class="comment">// 返回路径上匹配的文件</span></span><br><span class="line"></span><br><span class="line">fs.delete(Path, <span class="type">boolean</span> recursive);</span><br></pre></td></tr></table></figure>

<p>HDFS 读取数据</p>
<p><img src="/2020/07/21/Big-Data-Interview/5.png"></p>
<p>Namenode 只提供索引，不提供数据。错误时跳过，损坏时读副本。检查校验和。</p>
<p>网络拓扑</p>
<p><img src="/2020/07/21/Big-Data-Interview/7.png"></p>
<p>HDFS 写入数据</p>
<p><img src="/2020/07/21/Big-Data-Interview/6.png"></p>
<p>如果某datanode失败，会重新执行确认队列中的数据，且向namenode注册新身份，跳过故障节点。</p>
<p>写入副本的放置</p>
<p><img src="/2020/07/21/Big-Data-Interview/8.png"></p>
<p>一致模型：写入一个块即可看到该块，如果要同步读取，调用 sync() 方法。</p>
<p>distcp 分布式复制，多线程，两个 HDFS 之间传输。以 MapReduce 方式进行，只有 Map。</p>
<p>Hadoop Archives: 多个小文件合并成 .har 存储。以副本方式归档、归档后不可修改。</p>
<h2 id="Hadoop-I-O"><a href="#Hadoop-I-O" class="headerlink" title="Hadoop I&#x2F;O"></a>Hadoop I&#x2F;O</h2><p>CRC-32 校验和，每512字节计算32字节。</p>
<p>压缩Gzip，ZIP，bzip2，LZO。CompressionCodec 编码器，使用 native library 加速。CodecPool 编码器池。</p>
<p>压缩后无法分割，造成一个 map 处理多个块，无法数据本地化。</p>
<p>序列划：</p>
<ol>
<li>Writable 接口，write(DataOutput) 和 readFields(DataInput) 方法。</li>
<li>两个比较器，Writable 接口和RawComparator 接口。前者对象比较 CompareTo(A, B)，后者字节比较 compare(byte[], int, int, byte[], int, int)，默认的 compare 的实现会调用 compareTo， 因此也会反序列化成对象。</li>
</ol>
<p>Writable 类：BooleanWritable, ByteWritable, IntWritable, VIntWritable, FloatWritable, LongWritable, VLongWritable, DoubleWritable.</p>
<p>Text: 严格按照字节寻址，unicode会拆成两个地址。</p>
<p>NullWritable: 单实例，除此之外，其他 Writable 都可以修改。</p>
<p>ObjectWritable：可封装多种类型。</p>
<p>GenericWritable：可封装多种类型，但通过数组索引指明类型。</p>
<p>Writable集合：ArrayWritbale，TwoDArrayWritable，MapWritable，SortedMapWritable。数组，二维数字，Map，sortedMap。</p>
<p>HashPartitioner 使用 writable 中的 hashCode() 方法来选择分区。</p>
<p>SequenceFile：用来打包多个小文件，读取提供，next()，getCurrentValue() 方法。seek() 可定位，但不是记录边界时会出错，可用 sync() 定位到下一个同步点。文件为 name.seq。</p>
<p>MapFile：经过排序带有索引的 SequenceFile。文件为 name.map。其中包含一个 index 和一个 data 文件。index 中只保留部分索引，提供 get() 和 getClost() 读取方法。可用 fix() 方法重建索引，或者从 SequenceFile 转为 MapFile。</p>
<h2 id="Hadoop-测试"><a href="#Hadoop-测试" class="headerlink" title="Hadoop 测试"></a>Hadoop 测试</h2><p>对 Map 和 Reduce 单元测试</p>
<p>本地作业上测试驱动程序，MiniDFSCluster 和 MiniMRCluster 测试。</p>
<p>远程调试：设置 keep.failed.task.files 为 true，保存失败任务输入，登录目标节点，用 IsolationRunner 再次执行。</p>
<h2 id="Shuffle-和-排序"><a href="#Shuffle-和-排序" class="headerlink" title="Shuffle 和 排序"></a>Shuffle 和 排序</h2><p>Map 端：缓冲区 100M，超过 80% 开始内存溢写，分区，且分区内排序，排序后执行combiner，多个溢写文件会合并，少于3个不合并。可压缩。</p>
<p>Reduce 端：</p>
<ul>
<li>复制阶段：5个线程复制，先复制到内存，超出阈值溢写到磁盘。需解压。</li>
<li>排序阶段：根据合并系数进行合并，可能最后有多个文件。</li>
<li>reduce 阶段：多个文件输入 reduce 函数。</li>
</ul>
<p>优化原则：为 shuffle 指定更多空间，避免多次磁盘溢写。对于Map，主要就是避免把文件写入磁盘，例如使用 Combiner，增大 io.sort.mb 的值。对于 Reduce ，主要是把 Map 的结果尽可能地保存到内存中，同样也是要避免把中间结果写入磁盘。默认情况下，所有的内存都是分配给 Reduce 方法的。使用压缩，增大buffer size。</p>
<h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>speculative execution， 某个任务过慢，开启相同任务作为备份，谁先完成用谁，另外一个则终止。</p>
<p>JVM 重用</p>
<p>跳过坏记录：skipping 模式，失败两次后，第三次失败则记录并跳过。</p>
<p>多个实例向同一个文件写：先写入临时文件夹，先完成的允许修改。</p>
<h2 id="Hadoop-流格式"><a href="#Hadoop-流格式" class="headerlink" title="Hadoop 流格式"></a>Hadoop 流格式</h2><p>Input:</p>
<ul>
<li>FileInputFormat，过滤隐藏文件，分割原则：max(min_split, min(max_split, block_size))</li>
<li>CombineFileInputFormat，把多个小文件打包到一个输入中。</li>
<li>TextInputForamt</li>
<li>KeyValueTextInputForamt，第一个 tab 分开 key 和 value</li>
<li>NLineInputForamt，指定每个 map 收到多少行</li>
<li>SteamInputForamt, 处理 XML</li>
<li>SequenceFileInputForamt，可处理 SequenceFile</li>
<li>SequenceFileAsTextInputForamt，键值变成 Text</li>
<li>SequenceFileAsBinaryInputForamt，键值变成 Binary</li>
<li>MultipleInputs，在每一个路径上规定 Format</li>
<li>DBInputFormat</li>
</ul>
<p>Output:</p>
<ul>
<li>TextOutputForamt</li>
<li>SequenceFileOutputForamt</li>
<li>SequenceFileAsBinaryOutputForamt</li>
<li>MapFileOutputForamt</li>
<li>MltipleOutputFormat, 可控制文件名</li>
<li>MultipleOutpus，文件名后跟’-r-分区索引’，但灵活，功能多</li>
<li>LazyOutputForamt，有记录时才写文件，避免空文件</li>
</ul>
<h2 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h2><p>任务失败计数器可能减少。枚举定义计数器，也可以用组名定义动态计数器。可通过 Web 界面，命令行 和 JAVA API 获取计数器。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul>
<li>部分排序：利用 MapReduce，</li>
<li>部分排序查找：输出变为 MapFile</li>
<li>全局排序：partition 对 key 从小到大分区，利用采样器 Sampler 均匀分区，partition 文件写入分布式缓存全局共享。</li>
<li>二次排序：复合键，单键分区（到同一个reduce），单键分组（到同一组，setOutputValueGroupingComparator），自定义 comparator，按照双键排序（setOutputKeyComparatorClass）。</li>
</ul>
<p>python 流中，可用 KeyFieldBasedPartitioner 进行单键分割，用 KeyFiledBasedComparator 比较双键比较。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>速度 全内存链接 &gt; 部分内存链接 &gt; MapReduce</p>
<ul>
<li>Map 端：要求严格，用来链接多个作业输出，相同数量reducer，相同键，输出文件不可分。</li>
<li>Reduce 端：比如 1对多 链接，左半部分 key 为（链接键，0），右半部分 key 为（链接键，1），分区分组都按照连接键进行，0 和 1 保证了到达的先后顺序。</li>
</ul>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>使用 -files -archives，让APPlicationMaster直接去拷贝。引用计数和缓存清理。</p>
<p>或者通过API，addCacheFile() 和 addCacheArchive() 去指定拷贝。添加 symlink 符号链接。</p>
<h2 id="增加和移除节点"><a href="#增加和移除节点" class="headerlink" title="增加和移除节点"></a>增加和移除节点</h2><p><img src="/2020/07/21/Big-Data-Interview/9.png"></p>
<p><img src="/2020/07/21/Big-Data-Interview/10.png"></p>
<h2 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h2><p><img src="/2020/07/21/Big-Data-Interview/11.png"></p>
<h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><p>Hbase 是一个分布的，面向列的，排序的 map 存储。</p>
<p>基于Google Bigtable的开源实现，是一个具有高可靠性、高性能、面向列、可伸缩性、典型的key&#x2F;value分布式存储的nosql数据库系统，主要用于海量结构化和半结构化数据存储。它介于nosql和RDBMS之间，仅能通过行键（row key）和行键的range来检索数据，行数据存储是原子性的，仅支持单行事务（可通过hive支持来实现多表join等复杂操作）。HBase查询数据功能很简单，不支持join等复杂操作，不支持跨行和跨表事务</p>
<p>单元格内容为无解释的字节数组，行键也是字节数组，表以行键排序。面向列族的存储。</p>
<p>把表按照行切分成区域，区域分散在 HBase 集群上。</p>
<p>行级事务，行的更新时原子的。</p>
<p>两个目录表，-ROOT- 表包含 .META. 表所在区域。.META. 表包含所有用户空间区域列表。</p>
<p>区域自动平衡。</p>
<p><img src="/2020/07/21/Big-Data-Interview/12.png"></p>
<h2 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h2><p>Hive 中存放是表，是和 hdfs 的映射关系，hive 是逻辑上的数据仓库，实际操作的都是 hdfs 上的文件，HQL 就是用 sql 语法来写的 mr 程序。</p>
<p>Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供HQL语句（类SQL语言）查询功能，存储依赖于HDFS。支持多种计算引擎，如Spark、MapReduce（默认）、Tez；支持多种存储格式，如TextFile、SequenceFile、RCFile、ORC、Parquet（常用）；支持多种压缩格式，如gzip、lzo、snappy（常用）、bzip2</p>
<h2 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h2><p>hadoop生态圈上的数据传输工具。</p>
<p>可以将关系型数据库的数据导入非结构化的hdfs、hive或者bbase中，也可以将hdfs中的数据导出到关系型数据库或者文本文件中。</p>
<p>使用的是mr程序来执行任务，使用jdbc和关系型数据库进行交互。</p>
<h2 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h2><p>Flume 一个分布式、可靠的、高可用的用于数据采集、聚合和传输的系统。常用于日志采集系统中，支持定制各类数据发送方用于收集数据、通过自定义拦截器对数据进行简单的预处理并传输到各种数据接收方如HDFS、HBase、Kafka中。之前由Cloudera开发，后纳入Apache</p>
<h2 id="ALS-canopy-朴素贝叶斯分类-apriori"><a href="#ALS-canopy-朴素贝叶斯分类-apriori" class="headerlink" title="ALS, canopy, 朴素贝叶斯分类, apriori"></a>ALS, canopy, 朴素贝叶斯分类, apriori</h2><h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><p>Spark是一个快速、通用、可扩展、可容错的、内存迭代式计算的大数据分析引擎。目前生态体系主要包括用于批数据处理的SparkRDD、SparkSQL，用于流数据处理的SparkStreaming、Structured-Streaming，用于机器学习的Spark MLLib，用于图计算的Graphx以及用于统计分析的SparkR，支持Java、Scala、Python、R多种数据语言</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Big-data/" rel="tag">Big data</a> <a class="tag tag--primary tag--small t-none-link" href="/tags/Hadoop/" rel="tag">Hadoop</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/08/18/DNN-Computation-Optimization/"
                    data-tooltip="DNN Inference Accelerator"
                    aria-label="PREVIOUS: DNN Inference Accelerator"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/10/NLP-Summary/"
                    data-tooltip="NLP Summary"
                    aria-label="NEXT: NLP Summary"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitalk"></div>

            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 Joddiy Zhang. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/08/18/DNN-Computation-Optimization/"
                    data-tooltip="DNN Inference Accelerator"
                    aria-label="PREVIOUS: DNN Inference Accelerator"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2020/06/10/NLP-Summary/"
                    data-tooltip="NLP Summary"
                    aria-label="NEXT: NLP Summary"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Share this post"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                    title="Share on Facebook"
                    aria-label="Share on Facebook"
                >
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://twitter.com/intent/tweet?text=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                    title="Share on Twitter"
                    aria-label="Share on Twitter"
                >
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="https://plus.google.com/share?url=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                    title="Share on Google+"
                    aria-label="Share on Google+"
                >
                    <i class="fab fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a
                        class="post-action-btn btn btn--default"
                        href="#gitalk"
                        aria-label="Leave a comment"
                    >
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://www.facebook.com/sharer/sharer.php?u=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                        aria-label="Share on Facebook"
                    >
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://twitter.com/intent/tweet?text=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                        aria-label="Share on Twitter"
                    >
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="https://plus.google.com/share?url=https://joddiy.github.io/2020/07/21/Big-Data-Interview/"
                        aria-label="Share on Google+"
                    >
                        <i class="fab fa-google-plus" aria-hidden="true"></i><span>Share on Google+</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/14108933.jpeg" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Joddiy Zhang</h4>
        
            <div id="about-card-bio"><p><a href="mailto:&#x6a;&#111;&#100;&#x64;&#x69;&#121;&#x7a;&#104;&#97;&#x6e;&#103;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#x6a;&#111;&#100;&#x64;&#x69;&#121;&#x7a;&#104;&#97;&#x6e;&#103;&#x40;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a></p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Machine Learning Engineer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Singapore
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-sqrh47zm5nkjgifq4rx38uvns4r2rarrrvwuhjxiztyrddruca5ukl7nw6br.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="/assets/js/gitalk.js"></script>

        <script type="text/javascript">
          (function() {
            new Gitalk({
              clientID: 'bee9685b2dc9739b6bd5',
              clientSecret: 'a0c683f383a94fae6d021ab932f37f7e56899410',
              repo: 'joddiy.github.io',
              owner: 'joddiy',
              admin: ['joddiy'],
              id: '2020/07/21/Big-Data-Interview/',
              ...{"language":"en","perPage":10,"distractionFreeMode":false,"enableHotKey":true,"pagerDirection":"first"}
            }).render('gitalk')
          })()
        </script>
    




    </body>
</html>
